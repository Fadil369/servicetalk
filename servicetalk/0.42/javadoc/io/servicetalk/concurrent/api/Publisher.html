<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Publisher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Publisher";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":9,"i28":10,"i29":9,"i30":9,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":6,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":42,"i77":42,"i78":9,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":9,"i95":9,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":10,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":10,"i122":10,"i123":10,"i124":10,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10,"i131":10,"i132":10,"i133":10,"i134":10,"i135":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.servicetalk.concurrent.api</a></div>
<h2 title="Class Publisher" class="title">Class Publisher&lt;T&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.servicetalk.concurrent.api.Publisher&lt;T&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted.</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a></code>, <code><a href="internal/SubscribablePublisher.html" title="class in io.servicetalk.concurrent.api.internal">SubscribablePublisher</a></code>, <code><a href="TestPublisher.html" title="class in io.servicetalk.concurrent.api">TestPublisher</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">Publisher&lt;T&gt;</span>
extends java.lang.Object</pre>
<div class="block">An asynchronous computation that produces 0, 1 or more elements and may or may not terminate successfully or with
 an error.

 <h2>How to subscribe?</h2>

 This class does not provide a way to subscribe using a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> as such calls are
 ambiguous about the intent whether the subscribe is part of the same source (a.k.a an operator) or it is a terminal
 subscribe. If it is required to subscribe to a source, then a <a href="SourceAdapters.html" title="class in io.servicetalk.concurrent.api"><code>source adapter</code></a> can be used to
 convert to a <a href="../PublisherSource.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource</code></a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colSecond" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Publisher</a></span>()</code></th>
<td class="colLast">
<div class="block">New instance.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterCancel(java.lang.Runnable)">afterCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">afterFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 
     <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(java.lang.Runnable)">afterFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>afterFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 
     <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
     <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnComplete(java.lang.Runnable)">afterOnComplete</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
 is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnError(java.util.function.Consumer)">afterOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnNext(java.util.function.Consumer)">afterOnNext</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onNext)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onNext</code> <code>Consumer</code> argument <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is
 called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnSubscribe(java.util.function.Consumer)">afterOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterRequest(java.util.function.LongConsumer)">afterRequest</a></span>&#8203;(java.util.function.LongConsumer&nbsp;onRequest)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onRequest</code> <code>LongConsumer</code> argument <strong>after</strong>
 <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterSubscriber(java.util.function.Supplier)">afterSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes all the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterSubscription(java.util.function.Supplier)">afterSubscription</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;subscriptionSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> (via the <code>subscriptionSupplier</code> argument) for each new subscribe and
 invokes all the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>after</strong> the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeCancel(java.lang.Runnable)">beforeCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">beforeFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 
     <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(java.lang.Runnable)">beforeFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>beforeFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 
     <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
     <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnComplete(java.lang.Runnable)">beforeOnComplete</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
 is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnError(java.util.function.Consumer)">beforeOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnNext(java.util.function.Consumer)">beforeOnNext</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onNext)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onNext</code> <code>Consumer</code> argument <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is
 called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnSubscribe(java.util.function.Consumer)">beforeOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeRequest(java.util.function.LongConsumer)">beforeRequest</a></span>&#8203;(java.util.function.LongConsumer&nbsp;onRequest)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onRequest</code> <code>LongConsumer</code> argument <strong>before</strong>
 <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeSubscriber(java.util.function.Supplier)">beforeSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeSubscription(java.util.function.Supplier)">beforeSubscription</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;subscriptionSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> (via the <code>subscriptionSupplier</code> argument) on each call to
 subscribe and invokes all the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>before</strong> the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;BC extends <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;B&gt;,&#8203;B&gt;<br><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;B&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#buffer(io.servicetalk.concurrent.api.BufferStrategy)">buffer</a></span>&#8203;(<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;BC,&#8203;B&gt;&nbsp;strategy)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that buffers items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and emit those buffers instead of the
 individual items.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cast(java.lang.Class)">cast</a></span>&#8203;(java.lang.Class&lt;R&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Cast this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> from type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collect(java.util.function.Supplier,java.util.function.BiFunction)">collect</a></span>&#8203;(java.util.function.Supplier&lt;? extends R&gt;&nbsp;resultFactory,
       java.util.function.BiFunction&lt;? super R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;collector)</code></th>
<td class="colLast">
<div class="block">Collects all items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a single item.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completableOrError()">completableOrError</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Completable)">concat</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Listens for completion of <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Publisher)">concat</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Emits items emitted by <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Single)">concat</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Listens and emits the result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#defer(java.util.function.Supplier)">defer</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&gt;&nbsp;publisherSupplier)</code></th>
<td class="colLast">
<div class="block">Defers creation of a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> till it is subscribed.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#distinct()">distinct</a></span>()</code></th>
<td class="colLast">
<div class="block">Only emits distinct signals observed by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#empty()">empty</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that completes when subscribed without emitting any item to its
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failed(java.lang.Throwable)">failed</a></span>&#8203;(java.lang.Throwable&nbsp;cause)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that terminates its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> with an error without emitting any item to
 it.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filter(java.util.function.Predicate)">filter</a></span>&#8203;(java.util.function.Predicate&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Filters items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#firstOrElse(java.util.function.Supplier)">firstOrElse</a></span>&#8203;(java.util.function.Supplier&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;defaultValueSupplier)</code></th>
<td class="colLast">
<div class="block">Converts this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#firstOrError()">firstOrError</a></span>()</code></th>
<td class="colLast">
<div class="block">Ensures that this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits exactly a single <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> to its
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletable(java.util.function.Function)">flatMapCompletable</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletable(java.util.function.Function,int)">flatMapCompletable</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper,
                  int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletableDelayError(java.util.function.Function)">flatMapCompletableDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletableDelayError(java.util.function.Function,int)">flatMapCompletableDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper,
                            int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletableDelayError(java.util.function.Function,int,int)">flatMapCompletableDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper,
                            int&nbsp;maxConcurrency,
                            int&nbsp;maxDelayedErrorsHint)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapConcatIterable(java.util.function.Function)">flatMapConcatIterable</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that flattens each element returned by the <code>Iterable.iterator()</code> from
 <code>mapper</code>.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMerge(java.util.function.Function)">flatMapMerge</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMerge(java.util.function.Function,int)">flatMapMerge</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
            int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeDelayError(java.util.function.Function)">flatMapMergeDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeDelayError(java.util.function.Function,int)">flatMapMergeDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                      int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeDelayError(java.util.function.Function,int,int)">flatMapMergeDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                      int&nbsp;maxConcurrency,
                      int&nbsp;maxDelayedErrorsHint)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeSingle(java.util.function.Function)">flatMapMergeSingle</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeSingle(java.util.function.Function,int)">flatMapMergeSingle</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                  int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeSingleDelayError(java.util.function.Function)">flatMapMergeSingleDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeSingleDelayError(java.util.function.Function,int)">flatMapMergeSingleDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                            int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapMergeSingleDelayError(java.util.function.Function,int,int)">flatMapMergeSingleDelayError</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                            int&nbsp;maxConcurrency,
                            int&nbsp;maxDelayedErrorsHint)</code></th>
<td class="colLast">
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forEach(java.util.function.Consumer)">forEach</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;forEach)</code></th>
<td class="colLast">
<div class="block">Subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and invokes <code>forEach</code> <code>Consumer</code> for each item emitted by this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(T)">from</a></span>&#8203;(T&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>value</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(T...)">from</a></span>&#8203;(T...&nbsp;values)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all <code>values</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(T,T)">from</a></span>&#8203;(T&nbsp;v1,
    T&nbsp;v2)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>v1</code> and <code>v2</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(T,T,T)">from</a></span>&#8203;(T&nbsp;v1,
    T&nbsp;v2,
    T&nbsp;v3)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>v1</code>, <code>v2</code>, and <code>v3</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and
 then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromBlockingIterable(io.servicetalk.concurrent.BlockingIterable,java.util.function.LongSupplier,java.util.concurrent.TimeUnit)">fromBlockingIterable</a></span>&#8203;(<a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent">BlockingIterable</a>&lt;? extends T&gt;&nbsp;iterable,
                    java.util.function.LongSupplier&nbsp;timeoutSupplier,
                    java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will get a <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a> via
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> and emit all values to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;byte[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromInputStream(java.io.InputStream)">fromInputStream</a></span>&#8203;(java.io.InputStream&nbsp;stream)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all data from the <code>InputStream</code> to the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;byte[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromInputStream(java.io.InputStream,int)">fromInputStream</a></span>&#8203;(java.io.InputStream&nbsp;stream,
               int&nbsp;readChunkSize)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all data from the <code>InputStream</code> to the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromIterable(java.lang.Iterable)">fromIterable</a></span>&#8203;(java.lang.Iterable&lt;? extends T&gt;&nbsp;iterable)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will get an <code>Iterator</code> via <code>Iterable.iterator()</code>
 and emit all values to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupBy(java.util.function.Function)">groupBy</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends Key&gt;&nbsp;keySelector)</code></th>
<td class="colLast">
<div class="block">Splits items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into dynamically generated <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupBy(java.util.function.Function,int)">groupBy</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends Key&gt;&nbsp;keySelector,
       int&nbsp;queueLimit)</code></th>
<td class="colLast">
<div class="block">Splits items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into dynamically generated <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupBy(java.util.function.Function,int,int)">groupBy</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends Key&gt;&nbsp;keySelector,
       int&nbsp;queueLimit,
       int&nbsp;expectedGroupCountHint)</code></th>
<td class="colLast">
<div class="block">Splits items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into dynamically generated <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupToMany(java.util.function.Function,int)">groupToMany</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends java.util.Iterator&lt;? extends Key&gt;&gt;&nbsp;keySelector,
           int&nbsp;queueLimit)</code></th>
<td class="colLast">
<div class="block">The semantics are identical to <a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a> except that the <code>keySelector</code> can map each
 data to multiple keys.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupToMany(java.util.function.Function,int,int)">groupToMany</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends java.util.Iterator&lt;? extends Key&gt;&gt;&nbsp;keySelector,
           int&nbsp;queueLimit,
           int&nbsp;expectedGroupCountHint)</code></th>
<td class="colLast">
<div class="block">The semantics are identical to <a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a> except that the <code>keySelector</code> can map each
 data to multiple keys.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)">handleSubscribe</a></span>&#8203;(<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">Handles a subscriber to this <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ignoreElements()">ignoreElements</a></span>()</code></th>
<td class="colLast">
<div class="block">Ignores all elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftAsync(io.servicetalk.concurrent.api.PublisherOperator)">liftAsync</a></span>&#8203;(<a href="PublisherOperator.html" title="interface in io.servicetalk.concurrent.api">PublisherOperator</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftSync(io.servicetalk.concurrent.api.PublisherOperator)">liftSync</a></span>&#8203;(<a href="PublisherOperator.html" title="interface in io.servicetalk.concurrent.api">PublisherOperator</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftSyncToSingle(io.servicetalk.concurrent.api.PublisherToSingleOperator)">liftSyncToSingle</a></span>&#8203;(<a href="PublisherToSingleOperator.html" title="interface in io.servicetalk.concurrent.api">PublisherToSingleOperator</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#map(java.util.function.Function)">map</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transforms elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different type.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicast(int)">multicast</a></span>&#8203;(int&nbsp;minSubscribers)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicast(int,boolean)">multicast</a></span>&#8203;(int&nbsp;minSubscribers,
         boolean&nbsp;cancelUpstream)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicast(int,int)">multicast</a></span>&#8203;(int&nbsp;minSubscribers,
         int&nbsp;queueLimit)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicast(int,int,boolean)">multicast</a></span>&#8203;(int&nbsp;minSubscribers,
         int&nbsp;queueLimit,
         boolean&nbsp;cancelUpstream)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicast(int,int,boolean,java.util.function.Function)">multicast</a></span>&#8203;(int&nbsp;minSubscribers,
         int&nbsp;queueLimit,
         boolean&nbsp;cancelUpstream,
         java.util.function.Function&lt;java.lang.Throwable,&#8203;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;terminalResubscribe)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicast(int,int,java.util.function.Function)">multicast</a></span>&#8203;(int&nbsp;minSubscribers,
         int&nbsp;queueLimit,
         java.util.function.Function&lt;java.lang.Throwable,&#8203;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;terminalResubscribe)</code></th>
<td class="colLast">
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicastToExactly(int)">multicastToExactly</a></span>&#8203;(int&nbsp;expectedSubscribers)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#multicast(int)"><code>multicast(int)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multicastToExactly(int,int)">multicastToExactly</a></span>&#8203;(int&nbsp;expectedSubscribers,
                  int&nbsp;queueLimit)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#multicast(int,int)"><code>multicast(int, int)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that never emits any item to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and never call any terminal
 methods on it.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofType(java.lang.Class)">ofType</a></span>&#8203;(java.lang.Class&lt;R&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Filters items so that only non-<code>null</code> items of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> are emitted by the return value.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorComplete()">onErrorComplete</a></span>()</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal
 (e.g.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorComplete(java.lang.Class)">onErrorComplete</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> into a
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorComplete(java.util.function.Predicate)">onErrorComplete</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> into a
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.lang.Class,java.util.function.Function)">onErrorMap</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
          java.util.function.Function&lt;? super E,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> into a different error.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.util.function.Function)">onErrorMap</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different error.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.util.function.Predicate,java.util.function.Function)">onErrorMap</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
          java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> into a different error.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.lang.Class,java.util.function.Function)">onErrorResume</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
             java.util.function.Function&lt;? super E,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from errors emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> by using another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 provided by the passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.util.function.Function)">onErrorResume</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from any error emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> by using another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the
 passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.util.function.Predicate,java.util.function.Function)">onErrorResume</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from errors emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> by using another
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorReturn(java.lang.Class,java.util.function.Function)">onErrorReturn</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
             java.util.function.Function&lt;? super E,&#8203;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;itemSupplier)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorReturn(java.util.function.Function)">onErrorReturn</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;itemSupplier)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorReturn(java.util.function.Predicate,java.util.function.Function)">onErrorReturn</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;itemSupplier)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOn(io.servicetalk.concurrent.Executor)">publishOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">publishOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
         java.util.function.BooleanSupplier&nbsp;shouldOffload)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>static <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#range(int,int)">range</a></span>&#8203;(int&nbsp;begin,
     int&nbsp;end)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all <code>Integer</code>s within the range of
 [<code>begin</code>, <code>end</code>).</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>static <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#range(int,int,int)">range</a></span>&#8203;(int&nbsp;begin,
     int&nbsp;end,
     int&nbsp;stride)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all <code>Integer</code>s within the range of
 [<code>begin</code>, <code>end</code>) with an increment of <code>stride</code> between each signal.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeat(java.util.function.IntPredicate)">repeat</a></span>&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> when it completes and the passed <code>IntPredicate</code> returns
 <code>true</code>.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeatWhen(java.util.function.IntFunction)">repeatWhen</a></span>&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(io.servicetalk.concurrent.api.BiIntPredicate)">retry</a></span>&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">retryWhen</a></span>&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the
 supplied <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scanWith(java.util.function.Supplier)">scanWith</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="ScanWithMapper.html" title="interface in io.servicetalk.concurrent.api">ScanWithMapper</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&gt;&nbsp;mapperSupplier)</code></th>
<td class="colLast">
<div class="block">Apply a function to each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> as well as
 optionally concat one <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signal before the terminal signal is emitted downstream.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scanWith(java.util.function.Supplier,java.util.function.BiFunction)">scanWith</a></span>&#8203;(java.util.function.Supplier&lt;R&gt;&nbsp;initial,
        java.util.function.BiFunction&lt;R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;accumulator)</code></th>
<td class="colLast">
<div class="block">Apply a <code>BiFunction</code> to each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and an
 accumulated state.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scanWithLifetime(java.util.function.Supplier)">scanWithLifetime</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="ScanWithLifetimeMapper.html" title="interface in io.servicetalk.concurrent.api">ScanWithLifetimeMapper</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&gt;&nbsp;mapperSupplier)</code></th>
<td class="colLast">
<div class="block">Apply a function to each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> as well as
 optionally concat one <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signal before the terminal signal is emitted downstream.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shareContextOnSubscribe()">shareContextOnSubscribe</a></span>()</code></th>
<td class="colLast">
<div class="block">Signifies that when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a>.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeInternal(io.servicetalk.concurrent.PublisherSource.Subscriber)">subscribeInternal</a></span>&#8203;(<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">A internal subscribe method similar to <a href="../PublisherSource.html#subscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>PublisherSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOn(io.servicetalk.concurrent.Executor)">subscribeOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 
     All <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>handleSubscribe(PublisherSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">subscribeOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
           java.util.function.BooleanSupplier&nbsp;shouldOffload)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 
     All <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>handleSubscribe(PublisherSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeAtMost(long)">takeAtMost</a></span>&#8203;(long&nbsp;numElements)</code></th>
<td class="colLast">
<div class="block">Takes at most <code>numElements</code> elements from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeUntil(io.servicetalk.concurrent.api.Completable)">takeUntil</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;until)</code></th>
<td class="colLast">
<div class="block">Takes elements until <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully or with failure.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeWhile(java.util.function.Predicate)">takeWhile</a></span>&#8203;(java.util.function.Predicate&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Takes elements while <code>Predicate</code> is <code>true</code> and then cancel <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> of this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> once it returns <code>false</code>.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(long,java.util.concurrent.TimeUnit)">timeout</a></span>&#8203;(long&nbsp;duration,
       java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">timeout</a></span>&#8203;(long&nbsp;duration,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(java.time.Duration)">timeout</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(java.time.Duration,io.servicetalk.concurrent.Executor)">timeout</a></span>&#8203;(java.time.Duration&nbsp;duration,
       <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeoutTerminal(long,java.util.concurrent.TimeUnit)">timeoutTerminal</a></span>&#8203;(long&nbsp;duration,
               java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeoutTerminal(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">timeoutTerminal</a></span>&#8203;(long&nbsp;duration,
               java.util.concurrent.TimeUnit&nbsp;unit,
               <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeoutTerminal(java.time.Duration)">timeoutTerminal</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeoutTerminal(java.time.Duration,io.servicetalk.concurrent.Executor)">timeoutTerminal</a></span>&#8203;(java.time.Duration&nbsp;duration,
               <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;java.util.Collection&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletionStage()">toCompletionStage</a></span>()</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>CompletionStage</code> with a <code>Collection</code> containing the elements
 of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;java.util.concurrent.CompletionStage&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletionStage(java.util.function.Supplier,java.util.function.BiFunction)">toCompletionStage</a></span>&#8203;(java.util.function.Supplier&lt;? extends R&gt;&nbsp;resultFactory,
                 java.util.function.BiFunction&lt;? super R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;reducer)</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>CompletionStage</code> of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which represents all elements of
 this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;java.util.Collection&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFuture()">toFuture</a></span>()</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>Future</code> with a <code>Collection</code> containing the elements of this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;java.util.concurrent.Future&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFuture(java.util.function.Supplier,java.util.function.BiFunction)">toFuture</a></span>&#8203;(java.util.function.Supplier&lt;? extends R&gt;&nbsp;resultFactory,
        java.util.function.BiFunction&lt;? super R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;reducer)</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>Future</code> of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which represents all elements of this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>java.io.InputStream</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toInputStream(java.util.function.Function)">toInputStream</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;byte[]&gt;&nbsp;serializer)</code></th>
<td class="colLast">
<div class="block">Subscribes to <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and converts all signals received by the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to the
 returned <code>InputStream</code> following the below rules:
 
     <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> received by <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is used to
     request more data when required.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>java.io.InputStream</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toInputStream(java.util.function.Function,int)">toInputStream</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;byte[]&gt;&nbsp;serializer,
             int&nbsp;queueCapacity)</code></th>
<td class="colLast">
<div class="block">Subscribes to <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and converts all signals received by the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to the
 returned <code>InputStream</code> following the below rules:
 
     <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> received by <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is used to
     request more data when required.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code><a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent">BlockingIterable</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toIterable()">toIterable</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to an <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code><a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent">BlockingIterable</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toIterable(int)">toIterable</a></span>&#8203;(int&nbsp;queueCapacityHint)</code></th>
<td class="colLast">
<div class="block">Converts <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to an <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenCancel(java.lang.Runnable)">whenCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">whenFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any of the
 following terminal methods are called:
 
     <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(java.lang.Runnable)">whenFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 
     <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
     <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnComplete(java.lang.Runnable)">whenOnComplete</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument when <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnError(java.util.function.Consumer)">whenOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnNext(java.util.function.Consumer)">whenOnNext</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onNext)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onNext</code> <code>Consumer</code> argument when <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnSubscribe(java.util.function.Consumer)">whenOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenRequest(java.util.function.LongConsumer)">whenRequest</a></span>&#8203;(java.util.function.LongConsumer&nbsp;onRequest)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onRequest</code> <code>LongConsumer</code> argument when <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenSubscriber(java.util.function.Supplier)">whenSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> when the corresponding methods are called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenSubscription(java.util.function.Supplier)">whenSubscription</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;subscriptionSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> (via the <code>subscriptionSupplier</code> argument) for each new subscribe and
 invokes all the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods when the corresponding methods are called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s
 of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Publisher</h4>
<pre>protected&nbsp;Publisher()</pre>
<div class="block">New instance.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="map(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>map</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;map&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;mapper)</pre>
<div class="block">Transforms elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different type.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;R&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         results.add(mapper.apply(t));
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Function to transform each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that transforms elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different type.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/map.html">ReactiveX map operator.</a></dd>
</dl>
</li>
</ul>
<a id="cast(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cast</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;cast&#8203;(java.lang.Class&lt;R&gt;&nbsp;clazz)</pre>
<div class="block">Cast this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> from type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;R&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         results.add(clazz.cast(t));
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The resulting type of the cast operation.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - The type to cast to.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cast of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Terminates with a <code>ClassCastException</code> if
 signals cannot be cast to type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://reactivex.io/documentation/operators/map.html">ReactiveX cast operator.</a></dd>
</dl>
</li>
</ul>
<a id="filter(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;filter&#8203;(java.util.function.Predicate&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">Filters items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         if (predicate.test(t)) {
             results.add(t);
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - for the filter.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that only emits the items that pass the <code>predicate</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/filter.html">ReactiveX filter operator.</a></dd>
</dl>
</li>
</ul>
<a id="ofType(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofType</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;ofType&#8203;(java.lang.Class&lt;R&gt;&nbsp;clazz)</pre>
<div class="block">Filters items so that only non-<code>null</code> items of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> are emitted by the return value.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;R&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         if (clazz.isInstance(t)) {
             results.add((R) t);
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The resulting type of the cast operation.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - The type to filter and cast to.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that only emits</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://reactivex.io/documentation/operators/filter.html">ReactiveX ofType operator.</a></dd>
</dl>
</li>
</ul>
<a id="distinct()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinct</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;distinct()</pre>
<div class="block">Only emits distinct signals observed by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Signals are compared using
 <code>Object.hashCode()</code> and <code>Object.equals(Object)</code>.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     Set&lt;T&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         results.add(t);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits distinct signals observed by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX distinct operator.</a></dd>
</dl>
</li>
</ul>
<a id="scanWith(java.util.function.Supplier,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scanWith</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;scanWith&#8203;(java.util.function.Supplier&lt;R&gt;&nbsp;initial,
                                       java.util.function.BiFunction&lt;R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;accumulator)</pre>
<div class="block">Apply a <code>BiFunction</code> to each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and an
 accumulated state.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;R&gt; results = ...;
     R state = initial.get();
     for (T t : resultOfThisPublisher()) {
       state = accumulator.apply(state, t);
       results.add(state);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initial</code> - Invoked on each <a href="../PublisherSource.html#subscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>PublisherSource.subscribe(Subscriber)</code></a> and provides the initial state for
 each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dd><code>accumulator</code> - Used to accumulate the current state in combination with each
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that transforms elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different type.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/scan.html">ReactiveX scan operator.</a></dd>
</dl>
</li>
</ul>
<a id="scanWith(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scanWith</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;scanWith&#8203;(java.util.function.Supplier&lt;? extends <a href="ScanWithMapper.html" title="interface in io.servicetalk.concurrent.api">ScanWithMapper</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&gt;&nbsp;mapperSupplier)</pre>
<div class="block">Apply a function to each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> as well as
 optionally concat one <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signal before the terminal signal is emitted downstream.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;R&gt; results = ...;
     ScanWithMapper&lt;T, R&gt; mapper = mapperSupplier.get();
     try {
       for (T t : resultOfThisPublisher()) {
         results.add(mapper.mapOnNext(t));
       }
     } catch (Throwable cause) {
       if (mapTerminal.test(state)) {
         results.add(mapper.mapOnError(cause));
         return;
       }
       throw cause;
     }
     if (mapTerminal.test(state)) {
       results.add(mapper.mapOnComplete());
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapperSupplier</code> - Invoked on each <a href="../PublisherSource.html#subscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>PublisherSource.subscribe(Subscriber)</code></a> and maintains any necessary
 state for the mapping/accumulation for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that transforms elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different type.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/scan.html">ReactiveX scan operator.</a></dd>
</dl>
</li>
</ul>
<a id="scanWithLifetime(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scanWithLifetime</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;scanWithLifetime&#8203;(java.util.function.Supplier&lt;? extends <a href="ScanWithLifetimeMapper.html" title="interface in io.servicetalk.concurrent.api">ScanWithLifetimeMapper</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&gt;&nbsp;mapperSupplier)</pre>
<div class="block">Apply a function to each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> as well as
 optionally concat one <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signal before the terminal signal is emitted downstream.
 Additionally the <a href="ScanWithLifetimeMapper.html#afterFinally()"><code>ScanWithLifetimeMapper.afterFinally()</code></a> method will be invoked on terminal or cancel
 signals which enables cleanup of state (if required). This provides a similar lifetime management as
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a>.

 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;R&gt; results = ...;
     ScanWithLifetimeMapper&lt;T, R&gt; mapper = mapperSupplier.get();
     try {
         try {
           for (T t : resultOfThisPublisher()) {
             results.add(mapper.mapOnNext(t));
           }
         } catch (Throwable cause) {
           if (mapTerminal.test(state)) {
             results.add(mapper.mapOnError(cause));
             return;
           }
           throw cause;
         }
         if (mapTerminal.test(state)) {
           results.add(mapper.mapOnComplete());
         }
     } finally {
       mapper.afterFinally();
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapperSupplier</code> - Invoked on each <a href="../PublisherSource.html#subscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>PublisherSource.subscribe(Subscriber)</code></a> and maintains any necessary
 state for the mapping/accumulation for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that transforms elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different type.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/scan.html">ReactiveX scan operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorComplete()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorComplete()</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal
 (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         // ignored
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorComplete(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorComplete&#8203;(java.lang.Class&lt;E&gt;&nbsp;type)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> into a
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         if (!type.isInstance(cause)) {
           throw cause;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The <code>Throwable</code> type.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code>
 into a <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorComplete(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorComplete&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> into a
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         if (!predicate.test(cause)) {
           throw cause;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed to and
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal. Returns <code>false</code> to propagate the error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match
 <code>predicate</code> into a <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorReturn(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorReturn&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;itemSupplier)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         results.add(itemSupplier.apply(cause));
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>itemSupplier</code> - returns the element to emit to <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorReturn(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorReturn&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                        java.util.function.Function&lt;? super E,&#8203;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;itemSupplier)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         if (!type.isInstance(cause)) {
           throw cause;
         }
         results.add(itemSupplier.apply(cause));
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>itemSupplier</code> - returns the element to emit to <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorReturn(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorReturn&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                        java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;itemSupplier)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         if (!predicate.test(cause)) {
           throw cause;
         }
         results.add(itemSupplier.apply(cause));
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed to
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals. Returns <code>false</code> to
 propagate the error.</dd>
<dd><code>itemSupplier</code> - returns the element to emit to <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> signals (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorMap&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         throw mapper.apply(cause);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorMap&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                     java.util.function.Function&lt;? super E,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         if (type.isInstance(cause)) {
           throw mapper.apply(cause);
         } else {
           throw cause;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorMap&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                     java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     try {
         terminalOfThisPublisher();
     } catch (Throwable cause) {
         if (predicate.test(cause)) {
           throw mapper.apply(cause);
         } else {
           throw cause;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed via <code>mapper</code>. Returns
 <code>false</code> to propagate the original error.</dd>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which transform errors emitted on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorResume&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from any error emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> by using another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the
 passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     List&lt;T&gt; results;
     try {
         results = resultOfThisPublisher();
     } catch (Throwable cause) {
         // Note that nextFactory returning a error Publisher is like re-throwing (nextFactory shouldn't throw).
         results = nextFactory.apply(cause);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextFactory</code> - Returns the next <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, when this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that recovers from an error from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> by using another
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorResume&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                        java.util.function.Function&lt;? super E,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from errors emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>type</code> by using another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 provided by the passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     List&lt;T&gt; results;
     try {
         results = resultOfThisPublisher();
     } catch (Throwable cause) {
         if (type.isInstance(cause)) {
           // Note that nextFactory returning a error Publisher is like re-throwing (nextFactory shouldn't throw).
           results = nextFactory.apply(cause);
         } else {
           throw cause;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>nextFactory</code> - Returns the next <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, when this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that recovers from an error from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> by using another
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onErrorResume&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                        java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from errors emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which match <code>predicate</code> by using another
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     List&lt;T&gt; results;
     try {
         results = resultOfThisPublisher();
     } catch (Throwable cause) {
         if (predicate.test(cause)) {
           // Note that nextFactory returning a error Publisher is like re-throwing (nextFactory shouldn't throw).
           results = nextFactory.apply(cause);
         } else {
           throw cause;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed via <code>nextFactory</code>.
 Returns <code>false</code> to propagate the original error.</dd>
<dd><code>nextFactory</code> - Returns the next <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, when this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that recovers from an error from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> by using another
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMerge(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMerge</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMerge&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 To control the amount of concurrent processing done by this operator see <a href="#flatMapMerge(java.util.function.Function,int)"><code>flatMapMerge(Function, int)</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is an asynchronous stream, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;List&lt;R&gt;&gt;&gt; futures = ...; // assume this is thread safe
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         futures.add(e.submit(() -&gt; {
             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
         }));
     }
     List&lt;R&gt; results = new ArrayList&lt;&gt;(futures.size());
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;List&lt;R&gt;&gt; future : futures) {
         List&lt;R&gt; rList = future.get(); // Throws if the processing for this item failed.
         results.addAll(rList);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The type of mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which flattens the emissions from all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMerge(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMerge</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMerge&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                                           int&nbsp;maxConcurrency)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is an asynchronous stream, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;List&lt;R&gt;&gt;&gt; futures = ...; // assume this is thread safe
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         futures.add(e.submit(() -&gt; {
             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
         }));
     }
     List&lt;R&gt; results = new ArrayList&lt;&gt;(futures.size());
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;List&lt;R&gt;&gt; future : futures) {
         List&lt;R&gt; rList = future.get(); // Throws if the processing for this item failed.
         results.addAll(rList);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The type of mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum amount of outstanding upstream <a href="../PublisherSource.Subscription.html#request(long)"><code>demand</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which flattens the emissions from all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeDelayError(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 This is the same as <a href="#flatMapMerge(java.util.function.Function)"><code>flatMapMerge(Function)</code></a> just that if any mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by
 <code>mapper</code>, terminates with an error, the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will not immediately terminate. Instead,
 it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s to terminate and then terminate the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with all errors emitted by the mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.
 <p>
 To control the amount of concurrent processing done by this operator see
 <a href="#flatMapMergeDelayError(java.util.function.Function,int)"><code>flatMapMergeDelayError(Function, int)</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is an asynchronous stream, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;T&gt; tResults = resultOfThisPublisher();
     List&lt;R&gt; rResults = ...; // assume this is thread safe
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 List&lt;R&gt; rList = mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
                 rResults.addAll(rList);
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The type of mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which flattens the emissions from all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeDelayError(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                                                     int&nbsp;maxConcurrency)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 This is the same as <a href="#flatMapMerge(java.util.function.Function)"><code>flatMapMerge(Function)</code></a> just that if any mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by
 <code>mapper</code>, terminates with an error, the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will not immediately terminate. Instead,
 it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s to terminate and then terminate the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with all errors emitted by the mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is an asynchronous stream, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;T&gt; tResults = resultOfThisPublisher();
     List&lt;R&gt; rResults = ...; // assume this is thread safe
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 List&lt;R&gt; rList = mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
                 rResults.addAll(rList);
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The type of mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum amount of outstanding upstream <a href="../PublisherSource.Subscription.html#request(long)"><code>demand</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which flattens the emissions from all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeDelayError(java.util.function.Function,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                                                     int&nbsp;maxConcurrency,
                                                     int&nbsp;maxDelayedErrorsHint)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 This is the same as <a href="#flatMapMerge(java.util.function.Function)"><code>flatMapMerge(Function)</code></a> just that if any mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by
 <code>mapper</code>, terminates with an error, the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will not immediately terminate. Instead,
 it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s to terminate and then terminate the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with all errors emitted by the mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is an asynchronous stream, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;T&gt; tResults = resultOfThisPublisher();
     List&lt;R&gt; rResults = ...; // assume this is thread safe
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 List&lt;R&gt; rList = mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
                 rResults.addAll(rList);
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The type of mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into another <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum amount of outstanding upstream <a href="../PublisherSource.Subscription.html#request(long)"><code>demand</code></a>.</dd>
<dd><code>maxDelayedErrorsHint</code> - The maximum amount of errors that will be queued. After this point exceptions maybe
 discarded to reduce memory consumption.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which flattens the emissions from all mapped <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>s.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeSingle(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeSingle</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeSingle&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 To control the amount of concurrent processing done by this operator see
 <a href="#flatMapMergeSingle(java.util.function.Function,int)"><code>flatMapMergeSingle(Function, int)</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;R&gt;&gt; futures = ...; // assume this is thread safe
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         futures.add(e.submit(() -&gt; {
             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
         }));
     }
     List&lt;R&gt; results = new ArrayList&lt;&gt;(futures.size());
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;R&gt; future : futures) {
         R r = future.get(); // Throws if the processing for this item failed.
         results.add(r);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - <code>Function</code> to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted by each single produced by <code>mapper</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a>, 
<a href="#flatMapMergeSingle(java.util.function.Function,int)"><code>flatMapMergeSingle(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeSingle(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeSingle</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeSingle&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                                                 int&nbsp;maxConcurrency)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;R&gt;&gt; futures = ...; // assume this is thread safe
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         futures.add(e.submit(() -&gt; {
             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
         }));
     }
     List&lt;R&gt; results = new ArrayList&lt;&gt;(futures.size());
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;R&gt; future : futures) {
         R r = future.get(); // Throws if the processing for this item failed.
         results.add(r);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - <code>Function</code> to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum active <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s at any time.
 Even if the number of items requested by a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> is more than this number, this will never request
 more than this number at any point.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted by each single produced by <code>mapper</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeSingleDelayError(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeSingleDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeSingleDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 The behavior is the same as <a href="#flatMapMergeSingle(java.util.function.Function,int)"><code>flatMapMergeSingle(Function, int)</code></a> with the exception that if any
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>mapper</code>, terminates with an error, the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will not
 immediately terminate. Instead, it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to terminate and
 then terminate the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with all errors emitted by the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s produced by the
 <code>mapper</code>.
 <p>
 To control the amount of concurrent processing done by this operator see
 <a href="#flatMapMergeSingleDelayError(java.util.function.Function,int)"><code>flatMapMergeSingleDelayError(Function, int)</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;T&gt; tResults = resultOfThisPublisher();
     List&lt;R&gt; rResults = ...; // assume this is thread safe
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : tResults) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 R r = mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
                 rResults.add(r);
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - <code>Function</code> to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted by each single produced by <code>mapper</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a>, 
<a href="#flatMapMergeSingleDelayError(java.util.function.Function,int)"><code>flatMapMergeSingleDelayError(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeSingleDelayError(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeSingleDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeSingleDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                                                           int&nbsp;maxConcurrency)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 The behavior is the same as <a href="#flatMapMergeSingle(java.util.function.Function,int)"><code>flatMapMergeSingle(Function, int)</code></a> with the exception that if any
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>mapper</code>, terminates with an error, the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will not
 immediately terminate. Instead, it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to terminate and
 then terminate the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with all errors emitted by the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s produced by the
 <code>mapper</code>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;T&gt; tResults = resultOfThisPublisher();
     List&lt;R&gt; rResults = ...; // assume this is thread safe
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : tResults) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 R r = mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
                 rResults.add(r);
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - <code>Function</code> to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum active <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s at any time.
 Even if the number of items requested by a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> is more than this number,
 this will never request more than this number at any point.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted by each single produced by <code>mapper</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapMergeSingleDelayError(java.util.function.Function,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapMergeSingleDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapMergeSingleDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;mapper,
                                                           int&nbsp;maxConcurrency,
                                                           int&nbsp;maxDelayedErrorsHint)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; and flatten all signals
 emitted from each mapped <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt; into the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&lt;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>&gt;.
 <p>
 The behavior is the same as <a href="#flatMapMergeSingle(java.util.function.Function,int)"><code>flatMapMergeSingle(Function, int)</code></a> with the exception that if any
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>mapper</code>, terminates with an error, the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will not
 immediately terminate. Instead, it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to terminate and
 then terminate the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with all errors emitted by the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s produced by the
 <code>mapper</code>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;T&gt; tResults = resultOfThisPublisher();
     List&lt;R&gt; rResults = ...; // assume this is thread safe
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : tResults) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 R r = mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
                 rResults.add(r);
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - <code>Function</code> to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum active <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s at any time.
 Even if the number of items requested by a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> is more than this number,
 this will never request more than this number at any point.</dd>
<dd><code>maxDelayedErrorsHint</code> - The maximum amount of errors that will be queued. After this point exceptions maybe
 discarded to reduce memory consumption.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted by each single produced by <code>mapper</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMapCompletable(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletable</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletable&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.
 <p>
 If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> should wait for the termination of all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s when
 any one of them terminates with a failure, <a href="#flatMapCompletableDelayError(java.util.function.Function)"><code>flatMapCompletableDelayError(Function)</code></a> should be used.
 <p>
 To control the amount of concurrent processing done by this operator see
 <a href="#flatMapCompletable(java.util.function.Function,int)"><code>flatMapCompletable(Function, int)</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...; // assume this is thread safe
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         futures.add(e.submit(() -&gt; {
             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
         }));
     }
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;R&gt; future : futures) {
         future.get(); // Throws if the processing for this item failed.
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - <code>Function</code> to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the intermediate <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a>, 
<a href="#flatMapCompletable(java.util.function.Function,int)"><code>flatMapCompletable(Function, int)</code></a>, 
<a href="#flatMapCompletableDelayError(java.util.function.Function)"><code>flatMapCompletableDelayError(Function)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapCompletable(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletable</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletable&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper,
                                            int&nbsp;maxConcurrency)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.
 <p>
 If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> should wait for the termination of all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s when
 any one of them terminates with a failure, <a href="#flatMapCompletableDelayError(java.util.function.Function)"><code>flatMapCompletableDelayError(Function)</code></a> should be used.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...; // assume this is thread safe
     for (T t : resultOfThisPublisher()) {
         // Note that flatMap process results in parallel.
         futures.add(e.submit(() -&gt; {
             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.
         }));
     }
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;R&gt; future : futures) {
         future.get(); // Throws if the processing for this item failed.
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Function to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum active <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s at any time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the intermediate <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX flatMap operator.</a>, 
<a href="#flatMapCompletable(java.util.function.Function)"><code>flatMapCompletable(Function)</code></a>, 
<a href="#flatMapCompletableDelayError(java.util.function.Function,int)"><code>flatMapCompletableDelayError(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapCompletableDelayError(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletableDelayError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletableDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.
 <p>
 If any mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates with an error the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will not immediately
 terminate. Instead, it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to terminate.
 <p>
 To control the amount of concurrent processing done by this operator see
 <a href="#flatMapCompletableDelayError(java.util.function.Function,int)"><code>flatMapCompletableDelayError(Function, int)</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : tResults) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 mapper.apply(t); // Asynchronous result is flattened by this operator.
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (!errors.isEmpty()) {
         createAndThrowACompositeException(errors);
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Function to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the intermediate <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a>, 
<a href="#flatMapMergeSingleDelayError(java.util.function.Function,int)"><code>flatMapMergeSingleDelayError(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapCompletableDelayError(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletableDelayError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletableDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper,
                                                      int&nbsp;maxConcurrency)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.
 <p>
 If any mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates with an error the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will not immediately
 terminate. Instead, it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to terminate.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : tResults) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 mapper.apply(t); // Asynchronous result is flattened by this operator.
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (!errors.isEmpty()) {
         createAndThrowACompositeException(errors);
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Function to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum active <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s at any time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the intermediate <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a>, 
<a href="#flatMapMergeSingleDelayError(java.util.function.Function,int)"><code>flatMapMergeSingleDelayError(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapCompletableDelayError(java.util.function.Function,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletableDelayError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletableDelayError&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;mapper,
                                                      int&nbsp;maxConcurrency,
                                                      int&nbsp;maxDelayedErrorsHint)</pre>
<div class="block">Map each element of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and flatten all signals
 such that the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates when all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have terminated
 successfully or any one of them has terminated with a failure.
 <p>
 If any mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates with an error the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will not immediately
 terminate. Instead, it will wait for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and all mapped <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to terminate.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     Executor e = ...;
     List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
     CountDownLatch latch =  new CountDownLatch(tResults.size());
     for (T t : tResults) {
         // Note that flatMap process results in parallel.
         e.execute(() -&gt; {
             try {
                 mapper.apply(t); // Asynchronous result is flattened by this operator.
             } catch (Throwable cause) {
                 errors.add(cause);  // Asynchronous error is flatten into an error by this operator.
             } finally {
                 latch.countdown();
             }
         });
     }
     latch.await();
     if (!errors.isEmpty()) {
         createAndThrowACompositeException(errors);
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - Function to convert each item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dd><code>maxConcurrency</code> - Maximum active <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s at any time.</dd>
<dd><code>maxDelayedErrorsHint</code> - The maximum amount of errors that will be queued. After this point exceptions maybe
 discarded to reduce memory consumption.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the intermediate <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a>, 
<a href="#flatMapMergeSingleDelayError(java.util.function.Function,int)"><code>flatMapMergeSingleDelayError(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapConcatIterable(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapConcatIterable</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapConcatIterable&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that flattens each element returned by the <code>Iterable.iterator()</code> from
 <code>mapper</code>.
 <p>
 The mapper <code>Function</code> will only be called when the previously returned <code>Iterator</code> has returned
 <code>false</code> from <code>Iterator.hasNext()</code>.
 <p>
 This method provides similar capabilities as expanding each result into a collection and concatenating each
 collection in sequential programming:
 <pre><code>
     List&lt;R&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         Iterable&lt;? extends R&gt; itr = mapper.apply(t);
         itr.forEach(results::add);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The elements returned by the <code>Iterable</code>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - A <code>Function</code> that returns an <code>Iterable</code> for each element.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that flattens each element returned by the <code>Iterable.iterator()</code> from
 <code>mapper</code>. The results will be sequential for each <code>Iterator</code>, and overall for all calls to
 <code>Iterable.iterator()</code></dd>
</dl>
</li>
</ul>
<a id="whenOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenOnSubscribe&#8203;(java.util.function.Consumer&lt;? super <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>onSubscribe</code> will be invoked relative to
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is undefined. If you need strict ordering see
 <a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a> and <a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked when <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnNext(java.util.function.Consumer)"><code>beforeOnNext(Consumer)</code></a>, 
<a href="#afterOnNext(java.util.function.Consumer)"><code>afterOnNext(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenOnNext(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnNext</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenOnNext&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onNext)</pre>
<div class="block">Invokes the <code>onNext</code> <code>Consumer</code> argument when <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>onNext</code> will be invoked relative to <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is undefined. If
 you need strict ordering see <a href="#beforeOnNext(java.util.function.Consumer)"><code>beforeOnNext(Consumer)</code></a> and <a href="#afterOnNext(java.util.function.Consumer)"><code>afterOnNext(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  for (T t: resultOfThisPublisher()) {
      // NOTE: The order of operations here is not guaranteed by this method!
      processNext(t);
      onNext.accept(t);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onNext</code> - Invoked when <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnNext(java.util.function.Consumer)"><code>beforeOnNext(Consumer)</code></a>, 
<a href="#afterOnNext(java.util.function.Consumer)"><code>afterOnNext(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenOnComplete(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenOnComplete&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument when <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>onComplete</code> will be invoked relative to <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is undefined.
 If you need strict ordering see <a href="#beforeOnComplete(java.lang.Runnable)"><code>beforeOnComplete(Runnable)</code></a> and <a href="#afterOnComplete(java.lang.Runnable)"><code>afterOnComplete(Runnable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  List&lt;T&gt; results = resultOfThisPublisher();
  // NOTE: The order of operations here is not guaranteed by this method!
  onSuccess.accept(results);
  nextOperation(results);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - Invoked when <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnComplete(java.lang.Runnable)"><code>beforeOnComplete(Runnable)</code></a>, 
<a href="#afterOnComplete(java.lang.Runnable)"><code>afterOnComplete(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>onError</code> will be invoked relative to <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a> and
 <a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    List&lt;T&gt; results = resultOfThisPublisher();
  } catch (Throwable cause) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a>, 
<a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a> and <a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      List&lt;T&gt; results = resultOfThisPublisher();
  } finally {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked exactly once, when any of the following terminal methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a>, 
<a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any of the
 following terminal methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a> and
 <a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      List&lt;T&gt; results = resultOfThisPublisher();
  } catch(Throwable t) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a>, 
<a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenRequest(java.util.function.LongConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenRequest</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenRequest&#8203;(java.util.function.LongConsumer&nbsp;onRequest)</pre>
<div class="block">Invokes the <code>onRequest</code> <code>LongConsumer</code> argument when <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onRequest</code> - Invoked when <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="whenCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is undefined. If
 you need strict ordering see <a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a> and <a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a>, 
<a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="timeout(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeout&#8203;(long&nbsp;duration,
                                  java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls. The timer starts when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a>, 
<a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)"><code>timeout(long, TimeUnit, io.servicetalk.concurrent.Executor)</code></a></dd>
</dl>
</li>
</ul>
<a id="timeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeout&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls. The timer starts when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a>
 and the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a>, 
<a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)"><code>timeout(long, TimeUnit, io.servicetalk.concurrent.Executor)</code></a></dd>
</dl>
</li>
</ul>
<a id="timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeout&#8203;(long&nbsp;duration,
                                  java.util.concurrent.TimeUnit&nbsp;unit,
                                  <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls. The timer starts when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use for managing the timer
 notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(java.time.Duration,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeout&#8203;(java.time.Duration&nbsp;duration,
                                  <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between adjacent <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>
 calls. The timer starts when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dd><code>timeoutExecutor</code> - The <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use for managing the timer
 notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> calls.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeoutTerminal(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeoutTerminal</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeoutTerminal&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination. The timer starts
 when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration during which the Publisher must complete.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeoutTerminal(java.time.Duration,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeoutTerminal</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeoutTerminal&#8203;(java.time.Duration&nbsp;duration,
                                          <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination. The timer starts
 when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration during which the Publisher must complete.</dd>
<dd><code>timeoutExecutor</code> - The <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use for managing the timer
 notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeoutTerminal(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeoutTerminal</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeoutTerminal&#8203;(long&nbsp;duration,
                                          java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination. The timer starts
 when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration during which the Publisher must complete.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeoutTerminal(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeoutTerminal</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;timeoutTerminal&#8203;(long&nbsp;duration,
                                          java.util.concurrent.TimeUnit&nbsp;unit,
                                          <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination. The timer starts
 when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> from
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> will be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and
 the associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> will be <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration during which the Publisher must complete.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use for managing the timer
 notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will mimic the signals of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;concat&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;next)</pre>
<div class="block">Emits items emitted by <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     results.addAll(resultOfPublisher(next));
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>'s items that are emitted after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX concat operator.</a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Single)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;concat&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;next)</pre>
<div class="block">Listens and emits the result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     results.add(resultOfSingle(next));
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>'s result that is emitted after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and the result of <code>next</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX concat operator.</a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;concat&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</pre>
<div class="block">Listens for completion of <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully. Any error from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is forwarded to
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     resultOfCompletable(next);
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to wait for completion after <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates
 successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and then awaits successful
 completion of <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX concat operator.</a></dd>
</dl>
</li>
</ul>
<a id="retry(io.servicetalk.concurrent.api.BiIntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;retry&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</pre>
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>retryWhen((i, cause) -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to retry an operation under certain failure conditions and in sequential programming
 is similar to:
 <pre><code>
     public List&lt;T&gt; execute() {
         List&lt;T&gt; results = ...;
         return execute(0, results);
     }

     private List&lt;T&gt; execute(int attempts, List&lt;T&gt; results) {
         try {
             Iterator&lt;T&gt; itr = resultOfThisPublisher();
             while (itr.hasNext()) {
                 T t = itr.next(); // Any iteration with the Iterator may throw
                 results.add(t);
             }
             return results;
         } catch (Throwable cause) {
             if (shouldRetry.apply(attempts + 1, cause)) {
                 return execute(attempts + 1, results);
             } else {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRetry</code> - <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> that given the retry count and the most recent <code>Throwable</code>
 emitted from this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> determines if the operation should be retried.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and re-subscribes if an error is
 emitted if the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returned <code>true</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retryWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;retryWhen&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</pre>
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the
 supplied <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates with that error.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>retryWhen((i, cause) -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to retry an operation under certain failure conditions in an asynchronous fashion
 and in sequential programming is similar to:
 <pre><code>
     public List&lt;T&gt; execute() {
         List&lt;T&gt; results = ...;
         return execute(0, results);
     }

     private List&lt;T&gt; execute(int attempts, List&lt;T&gt; results) {
         try {
             Iterator&lt;T&gt; itr = resultOfThisPublisher();
             while (itr.hasNext()) {
                 T t = itr.next(); // Any iteration with the Iterator may throw
                 results.add(t);
             }
             return results;
         } catch (Throwable cause) {
             try {
                 shouldRetry.apply(attempts + 1, cause); // Either throws or completes normally
                 execute(attempts + 1, results);
             } catch (Throwable ignored) {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>retryWhen</code> - <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> that given the retry count and the most recent <code>Throwable</code> emitted
 from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, that error
 is emitted from the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, otherwise, original <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is re-subscribed when this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and re-subscribes if an error is
 emitted and <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeat(java.util.function.IntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;repeat&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</pre>
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> when it completes and the passed <code>IntPredicate</code> returns
 <code>true</code>.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>repeatWhen(i -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to repeat an operation multiple times and in sequential programming is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     int i = 0;
     do {
         results.addAll(resultOfThisPublisher());
     } while (shouldRepeat.test(++i));
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRepeat</code> - <code>IntPredicate</code> that given the repeat count determines if the operation should be
 repeated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and re-subscribes when it completes
 if the passed <code>IntPredicate</code> returns <code>true</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX repeat operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeatWhen(java.util.function.IntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeatWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;repeatWhen&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</pre>
<div class="block">Re-subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is completed.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>repeatWhen(i -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to repeat an operation multiple times when in an asynchronous fashion and in
 sequential programming is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     int i = 0;
     while (true) {
         results.addAll(resultOfThisPublisher());
         try {
             repeatWhen.apply(++i); // Either throws or completes normally
         } catch (Throwable cause) {
             break;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>repeatWhen</code> - <code>IntFunction</code> that given the repeat count returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error repeat is terminated, otherwise, original <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is
 re-subscribed when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and re-subscribes if an error is
 emitted and <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>IntFunction</code> completes successfully.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="takeAtMost(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeAtMost</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;takeAtMost&#8203;(long&nbsp;numElements)</pre>
<div class="block">Takes at most <code>numElements</code> elements from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 If no terminal event is received before receiving <code>numElements</code> elements, <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> for the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> is cancelled.
 <p>
 This method provides a means to take a limited number of results from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and in sequential
 programming is similar to:
 <pre><code>
     List&lt;T&gt; results = ...;
     int i = 0;
     for (T t : resultOfThisPublisher()) {
         if (++i &gt; numElements) {
             break;
         }
         results.add(t);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>numElements</code> - Number of elements to take.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits at most <code>numElements</code> elements from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/take.html">ReactiveX take operator.</a></dd>
</dl>
</li>
</ul>
<a id="takeWhile(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeWhile</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;takeWhile&#8203;(java.util.function.Predicate&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">Takes elements while <code>Predicate</code> is <code>true</code> and then cancel <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> of this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> once it returns <code>false</code>.
 <p>
 This method provides a means to take a limited number of results from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and in sequential
 programming is similar to:
 <pre><code>
     List&lt;T&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         if (!predicate.test(result)) {
             break;
         }
         results.add(t);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - <code>Predicate</code> that is checked before emitting any item to a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 If this predicate returns <code>true</code>, that item is emitted, else <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> is cancelled.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that only emits the items as long as the <code>Predicate.test(Object)</code> method
 returns <code>true</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/takewhile.html">ReactiveX takeWhile operator.</a></dd>
</dl>
</li>
</ul>
<a id="takeUntil(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeUntil</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;takeUntil&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;until)</pre>
<div class="block">Takes elements until <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully or with failure.
 <p>
 This method provides a means to take a limited number of results from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and in sequential
 programming is similar to:
 <pre><code>
     List&lt;T&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         if (isCompleted(until)) {
             break;
         }
         takeResults.add(t);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>until</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, termination of which, terminates the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that only emits the items till <code>until</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is completed.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/takeuntil.html">ReactiveX takeUntil operator.</a></dd>
</dl>
</li>
</ul>
<a id="groupBy(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre class="methodSignature">public final&nbsp;&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;groupBy&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends Key&gt;&nbsp;keySelector)</pre>
<div class="block">Splits items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into dynamically generated <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.
 Item to group association is done by <code>keySelector</code> <code>Function</code>. If the selector selects a key which is
 previously seen and its associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> has not yet cancelled its <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>, this item
 is sent to that <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>. Otherwise a new <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> is created and emitted from the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 Flow control
 <p>
 Multiple <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s (for multiple <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s) request items individually from this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Since, there is no way for a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to only request elements for its group,
 elements requested by one group may end up producing items for a different group, which has not yet requested
 enough. This will cause items to be queued per group which can not be emitted due to lack of demand. This queue
 size can be controlled via <a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a>.
 <p>
 Cancellation
 <p>
 If the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> cancels its <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>, and there are no
 active <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s then upstream will be cancelled.
 <p>
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of individual <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s can cancel their <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s at any point.
 If any new item is emitted for the cancelled <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>, a new <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> will be
 emitted from the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any queued items for a cancelled <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> for a
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> will be discarded and hence will not be emitted if the same <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> is
 emitted again.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     Map&lt;Key, List&lt;T&gt;&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         Key k = keySelector.apply(result);
         List&lt;T&gt; v = results.get(k);
         if (v == null) {
             v = // new List
             results.put(k, v);
         }
         v.add(result);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>Key</code> - Type of <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> keys.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySelector</code> - <code>Function</code> to assign an item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s for new <code>key</code>s as emitted by
 <code>keySelector</code> <code>Function</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX groupBy operator.</a></dd>
</dl>
</li>
</ul>
<a id="groupBy(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre class="methodSignature">public final&nbsp;&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;groupBy&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends Key&gt;&nbsp;keySelector,
                                                                    int&nbsp;queueLimit)</pre>
<div class="block">Splits items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into dynamically generated <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.
 Item to group association is done by <code>keySelector</code> <code>Function</code>. If the selector selects a key which is
 previously seen and its associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> has not yet cancelled its <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>, this item
 is sent to that <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>. Otherwise a new <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> is created and emitted from the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 Flow control
 <p>
 Multiple <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s (for multiple <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s) request items individually from this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Since, there is no way for a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to only request elements for its group,
 elements requested by one group may end up producing items for a different group, which has not yet requested
 enough. This will cause items to be queued per group which can not be emitted due to lack of demand. This queue
 size can be controlled with the <code>queueLimit</code> argument.
 <p>
 Cancellation
 <p>
 If the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> cancels its <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>, and there are no
 active <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s then upstream will be cancelled.
 <p>
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of individual <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s can cancel their <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s at any point.
 If any new item is emitted for the cancelled <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>, a new <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> will be
 emitted from the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any queued items for a cancelled <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> for a
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> will be discarded and hence will not be emitted if the same <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> is
 emitted again.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     Map&lt;Key, List&lt;T&gt;&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         Key k = keySelector.apply(result);
         List&lt;T&gt; v = results.get(k);
         if (v == null) {
             v = // new List
             results.put(k, v);
         }
         v.add(result);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>Key</code> - Type of <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> keys.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySelector</code> - <code>Function</code> to assign an item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each grouped <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to
 compensate for unequal demand. This also applies to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which may also have to queue
 signals.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s for new <code>key</code>s as emitted by
 <code>keySelector</code> <code>Function</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX groupBy operator.</a></dd>
</dl>
</li>
</ul>
<a id="groupBy(java.util.function.Function,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre class="methodSignature">public final&nbsp;&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;groupBy&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends Key&gt;&nbsp;keySelector,
                                                                    int&nbsp;queueLimit,
                                                                    int&nbsp;expectedGroupCountHint)</pre>
<div class="block">Splits items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into dynamically generated <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.
 Item to group association is done by <code>keySelector</code> <code>Function</code>. If the selector selects a key which is
 previously seen and its associated <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> has not yet cancelled its <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>, this item
 is sent to that <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>. Otherwise a new <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> is created and emitted from the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 Flow control
 <p>
 Multiple <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s (for multiple <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s) request items individually from this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Since, there is no way for a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to only request elements for its group,
 elements requested by one group may end up producing items for a different group, which has not yet requested
 enough. This will cause items to be queued per group which can not be emitted due to lack of demand. This queue
 size can be controlled with the <code>queueLimit</code> argument.
 <p>
 Cancellation
 <p>
 If the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> cancels its <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>, and there are no
 active <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s then upstream will be cancelled.
 <p>
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of individual <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s can cancel their <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s at any point.
 If any new item is emitted for the cancelled <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>, a new <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> will be
 emitted from the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any queued items for a cancelled <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> for a
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> will be discarded and hence will not be emitted if the same <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> is
 emitted again.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     Map&lt;Key, List&lt;T&gt;&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         Key k = keySelector.apply(result);
         List&lt;T&gt; v = results.get(k);
         if (v == null) {
             v = // new List
             results.put(k, v);
         }
         v.add(result);
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>Key</code> - Type of <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> keys.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySelector</code> - <code>Function</code> to assign an item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each grouped <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to
 compensate for unequal demand. This also applies to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which may also have to queue
 signals.</dd>
<dd><code>expectedGroupCountHint</code> - Expected number of groups that would be emitted by <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 This is just a hint for internal data structures and does not have to be precise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s for new <code>key</code>s as emitted by
 <code>keySelector</code> <code>Function</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX groupBy operator.</a></dd>
</dl>
</li>
</ul>
<a id="groupToMany(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupToMany</h4>
<pre class="methodSignature">public final&nbsp;&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;groupToMany&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends java.util.Iterator&lt;? extends Key&gt;&gt;&nbsp;keySelector,
                                                                        int&nbsp;queueLimit)</pre>
<div class="block">The semantics are identical to <a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a> except that the <code>keySelector</code> can map each
 data to multiple keys.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     Map&lt;Key, List&lt;T&gt;&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         Iterator&lt;Key&gt; keys = keySelector.apply(result);
         for (Key key : keys) {
             List&lt;T&gt; v = results.get(key);
             if (v == null) {
                 v = // new List
                 results.put(key, v);
             }
             v.add(result);
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>Key</code> - Type of <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> keys.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySelector</code> - <code>Function</code> to assign an item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to multiple
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each grouped <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to
 compensate for unequal demand. This also applies to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which may also have to queue
 signals.
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned from this method not requesting enough via <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s for new <code>key</code>s as emitted by
 <code>keySelector</code> <code>Function</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="groupToMany(java.util.function.Function,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupToMany</h4>
<pre class="methodSignature">public final&nbsp;&lt;Key&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api">GroupedPublisher</a>&lt;Key,&#8203;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;groupToMany&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends java.util.Iterator&lt;? extends Key&gt;&gt;&nbsp;keySelector,
                                                                        int&nbsp;queueLimit,
                                                                        int&nbsp;expectedGroupCountHint)</pre>
<div class="block">The semantics are identical to <a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a> except that the <code>keySelector</code> can map each
 data to multiple keys.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     Map&lt;Key, List&lt;T&gt;&gt; results = ...;
     for (T t : resultOfThisPublisher()) {
         Iterator&lt;Key&gt; keys = keySelector.apply(result);
         for (Key key : keys) {
             List&lt;T&gt; v = results.get(key);
             if (v == null) {
                 v = // new List
                 results.put(key, v);
             }
             v.add(result);
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>Key</code> - Type of <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a> keys.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySelector</code> - <code>Function</code> to assign an item emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to multiple
 <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each grouped <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to
 compensate for unequal demand. This also applies to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which may also have to queue
 signals.</dd>
<dd><code>expectedGroupCountHint</code> - Expected number of groups that would be emitted by <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 This is just a hint for internal data structures and does not have to be precise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <a href="GroupedPublisher.html" title="class in io.servicetalk.concurrent.api"><code>GroupedPublisher</code></a>s for new <code>key</code>s as emitted by
 <code>keySelector</code> <code>Function</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#groupBy(java.util.function.Function,int)"><code>groupBy(Function, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="multicastToExactly(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicastToExactly</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicastToExactly&#8203;(int&nbsp;expectedSubscribers)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#multicast(int)"><code>multicast(int)</code></a>.</div>
</div>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that multicasts all the signals to exactly <code>expectedSubscribers</code>.
 <p>
 Depending on <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> demand it is possible that data maybe queued before being
 delivered to each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>! For example if there are 2 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s and the first calls
 <a href="../PublisherSource.Subscription.html#request(long)"><code>request(10)</code></a>, and the second only calls
 <a href="../PublisherSource.Subscription.html#request(long)"><code>request(1)</code></a>, then 9 elements will be queued to deliver to second when more
 <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> demand is made.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...;
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expectedSubscribers</code> - The number of expected subscribe calls required on the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that allows exactly <code>expectedSubscribers</code> subscribes.</dd>
</dl>
</li>
</ul>
<a id="multicastToExactly(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicastToExactly</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicastToExactly&#8203;(int&nbsp;expectedSubscribers,
                                             int&nbsp;queueLimit)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#multicast(int,int)"><code>multicast(int, int)</code></a>.</div>
</div>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that allows exactly <code>expectedSubscribers</code> subscribes.
 The events from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> object will be delivered to each
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Depending on <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> demand it is possible that data maybe queued before being
 delivered to each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>! For example if there are 2 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s and the first calls
 <a href="../PublisherSource.Subscription.html#request(long)"><code>request(10)</code></a>, and the second only calls
 <a href="../PublisherSource.Subscription.html#request(long)"><code>request(1)</code></a>, then 9 elements will be queued to deliver to second when more
 <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> demand is made.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...;
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expectedSubscribers</code> - The number of expected subscribe calls required on the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to compensate
 for unequal demand.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that allows exactly <code>expectedSubscribers</code> subscribes.</dd>
</dl>
</li>
</ul>
<a id="multicast(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicast</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicast&#8203;(int&nbsp;minSubscribers)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s may subscribe after the upstream subscribe, but signals that were delivered before
 the downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> subscribed will not be queued.
 <p>
 Upstream outstanding <a href="../PublisherSource.Subscription.html#request(long)"><code>Subscription demand</code></a> may be limited to provide an upper
 bound on queue sizes (e.g. demand from downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s will vary).
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...; // simulating multiple Subscribers
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minSubscribers</code> - The upstream subscribe operation will not happen until after this many <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>
 subscribe to the return value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX multicast operator</a></dd>
</dl>
</li>
</ul>
<a id="multicast(int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicast</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicast&#8203;(int&nbsp;minSubscribers,
                                    boolean&nbsp;cancelUpstream)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s may subscribe after the upstream subscribe, but signals that were delivered before
 the downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> subscribed will not be queued.
 <p>
 Upstream outstanding <a href="../PublisherSource.Subscription.html#request(long)"><code>Subscription demand</code></a> may be limited to provide an upper
 bound on queue sizes (e.g. demand from downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s will vary).
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...; // simulating multiple Subscribers
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minSubscribers</code> - The upstream subscribe operation will not happen until after this many <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>
 subscribe to the return value.</dd>
<dd><code>cancelUpstream</code> - <code>true</code> if upstream should be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> when all
 downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s cancel. <code>false</code> means that cancel will not be propagated upstream even if
 all downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s cancel, and the upstream Subscription will stay valid until termination.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX multicast operator</a></dd>
</dl>
</li>
</ul>
<a id="multicast(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicast</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicast&#8203;(int&nbsp;minSubscribers,
                                    int&nbsp;queueLimit)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s may subscribe after the upstream subscribe, but signals that were delivered before
 the downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> subscribed will not be queued.
 <p>
 Upstream outstanding <a href="../PublisherSource.Subscription.html#request(long)"><code>Subscription demand</code></a> may be limited to provide an upper
 bound on queue sizes (e.g. demand from downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s will vary).
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...; // simulating multiple Subscribers
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minSubscribers</code> - The upstream subscribe operation will not happen until after this many <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>
 subscribe to the return value.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to compensate
 for unequal demand.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX multicast operator</a></dd>
</dl>
</li>
</ul>
<a id="multicast(int,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicast</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicast&#8203;(int&nbsp;minSubscribers,
                                    int&nbsp;queueLimit,
                                    boolean&nbsp;cancelUpstream)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s may subscribe after the upstream subscribe, but signals that were delivered before
 the downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> subscribed will not be queued.
 <p>
 Upstream outstanding <a href="../PublisherSource.Subscription.html#request(long)"><code>Subscription demand</code></a> may be limited to provide an upper
 bound on queue sizes (e.g. demand from downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s will vary).
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...; // simulating multiple Subscribers
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minSubscribers</code> - The upstream subscribe operation will not happen until after this many <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>
 subscribe to the return value.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to compensate
 for unequal demand.</dd>
<dd><code>cancelUpstream</code> - <code>true</code> if upstream should be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> when all
 downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s cancel.<code>false</code> means that cancel will not be propagated upstream even if
 all downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s cancel, and the upstream Subscription will stay valid until termination.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX multicast operator</a></dd>
</dl>
</li>
</ul>
<a id="multicast(int,int,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicast</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicast&#8203;(int&nbsp;minSubscribers,
                                    int&nbsp;queueLimit,
                                    java.util.function.Function&lt;java.lang.Throwable,&#8203;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;terminalResubscribe)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s may subscribe after the upstream subscribe, but signals that were delivered before
 the downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> subscribed will not be queued.
 <p>
 Upstream outstanding <a href="../PublisherSource.Subscription.html#request(long)"><code>Subscription demand</code></a> may be limited to provide an upper
 bound on queue sizes (e.g. demand from downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s will vary).
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...; // simulating multiple Subscribers
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minSubscribers</code> - The upstream subscribe operation will not happen until after this many <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>
 subscribe to the return value.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to compensate
 for unequal demand.</dd>
<dd><code>terminalResubscribe</code> - A <code>Function</code> that is invoked when a terminal signal arrives from upstream, and
 returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> whose termination resets the state of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and allows
 for downstream resubscribing. The argument to this function is as follows:
 <ul>
     <li><code>null</code> if upstream terminates with <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li>otherwise the <code>Throwable</code> from <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX multicast operator</a></dd>
</dl>
</li>
</ul>
<a id="multicast(int,int,boolean,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multicast</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;multicast&#8203;(int&nbsp;minSubscribers,
                                    int&nbsp;queueLimit,
                                    boolean&nbsp;cancelUpstream,
                                    java.util.function.Function&lt;java.lang.Throwable,&#8203;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;terminalResubscribe)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.
 <p>
 Downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s may subscribe after the upstream subscribe, but signals that were delivered before
 the downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> subscribed will not be queued.
 <p>
 Upstream outstanding <a href="../PublisherSource.Subscription.html#request(long)"><code>Subscription demand</code></a> may be limited to provide an upper
 bound on queue sizes (e.g. demand from downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s will vary).
 In sequential programming this is similar to the following:
 <pre><code>
     List&lt;T&gt; results = resultOfThisPublisher();
     List&lt;List&lt;T&gt;&gt; multiResults = ...; // simulating multiple Subscribers
     for (int i = 0; i &lt; expectedSubscribers; ++i) {
         multiResults.add(results);
     }
     return multiResults;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minSubscribers</code> - The upstream subscribe operation will not happen until after this many <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>
 subscribe to the return value.</dd>
<dd><code>queueLimit</code> - The number of elements which will be queued for each <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> in order to compensate
 for unequal demand.</dd>
<dd><code>cancelUpstream</code> - <code>true</code> if upstream should be <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> when all
 downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s cancel. <code>false</code> means that cancel will not be propagated upstream even if
 all downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s cancel, and the upstream Subscription will stay valid until termination.</dd>
<dd><code>terminalResubscribe</code> - A <code>Function</code> that is invoked when a terminal signal arrives from upstream, and
 returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> whose termination resets the state of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and allows
 for downstream resubscribing. The argument to this function is as follows:
 <ul>
     <li><code>null</code> if upstream terminates with <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li>otherwise the <code>Throwable</code> from <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that subscribes a single time upstream but allows for multiple downstream
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s. Signals from upstream will be multicast to each downstream <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX multicast operator</a></dd>
</dl>
</li>
</ul>
<a id="buffer(io.servicetalk.concurrent.api.BufferStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre class="methodSignature">public final&nbsp;&lt;BC extends <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;B&gt;,&#8203;B&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;B&gt;&nbsp;buffer&#8203;(<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;BC,&#8203;B&gt;&nbsp;strategy)</pre>
<div class="block">Create a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that buffers items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and emit those buffers instead of the
 individual items.
 <p>
 In sequential programming this is similar to the following:
 <pre><code>
     List accumulators = strategy.boundaries();
     List buffers = ...;
     BC currentAccumulator;
     for (T t : resultOfThisPublisher()) {
         // This is an approximation; accumulators are emitted asynchronously.
         BC nextAccumulator = accumulators.remove(0).get();
         buffers.add(currentAccumulator.finish());
         currentAccumulator = nextAccumulator;
         currentAccumulator.add(t);
     }
     return buffers;
 </code></pre>
 Notes:
 <ol>
     <li>If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> does not emit items within the <a href="BufferStrategy.html#boundaries()"><code>boundary</code></a>,
     it's expected it will emit an empty <a href="BufferStrategy.Accumulator.html#finish()"><code>accumulated value</code></a> as the result of
     accumulating nothing. Use <a href="#filter(java.util.function.Predicate)"><code>filter(Predicate)</code></a> operator if empty accumulations have to be discarded.
     </li>
     <li>If more than one <a href="BufferStrategy.html#boundaries()"><code>boundary</code></a> is emitted while this operator
     <a href="BufferStrategy.Accumulator.html#accumulate(T)"><code>accumulates</code></a> or emits the
     <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>next</code></a> result of accumulation, those boundaries will be
     discarded without invoking <a href="BufferStrategy.Accumulator.html#finish()"><code>BufferStrategy.Accumulator.finish()</code></a> method.</li>
 </ol></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>BC</code> - Type of the <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> to buffer items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>B</code> - Type of the buffer emitted from the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>strategy</code> - A <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> to use for buffering items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that buffers items from this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and emit those buffers instead of the
 individual items.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX buffer operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeOnSubscribe&#8203;(java.util.function.Consumer&lt;? super <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>before</strong>
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnNext(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnNext</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeOnNext&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onNext)</pre>
<div class="block">Invokes the <code>onNext</code> <code>Consumer</code> argument <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is
 called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  List&lt;T&gt; results = resultOfThisPublisher();
  for (T result : results) {
      onNext.accept(result);
  }
  nextOperation(results);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onNext</code> - Invoked <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s
 of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    List&lt;T&gt; results = resultOfThisPublisher();
  } catch (Throwable cause) {
      onError.accept(cause);
      nextOperation(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnComplete(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeOnComplete&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
 is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
   List&lt;T&gt; results = resultOfThisPublisher();
   onComplete.run();
   nextOperation(results);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - Invoked <strong>before</strong> <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeRequest(java.util.function.LongConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeRequest</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeRequest&#8203;(java.util.function.LongConsumer&nbsp;onRequest)</pre>
<div class="block">Invokes the <code>onRequest</code> <code>LongConsumer</code> argument <strong>before</strong>
 <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onRequest</code> - Invoked <strong>before</strong> <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>beforeFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      List&lt;T&gt; results = resultOfThisPublisher();
  } finally {
      doFinally.run();
      nextOperation(); // Maybe notifying of cancellation, or termination
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      List&lt;T&gt; results = resultOfThisPublisher();
  } catch(Throwable t) {
      doFinally.onError(t);
      nextOperation(); // Maybe notifying of cancellation, or termination
      return;
  }
  doFinally.onComplete();
  nextOperation(); // Maybe notifying of cancellation, or termination
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeSubscription(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeSubscription</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;beforeSubscription&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;subscriptionSupplier)</pre>
<div class="block">Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> (via the <code>subscriptionSupplier</code> argument) on each call to
 subscribe and invokes all the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>before</strong> the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriptionSupplier</code> - Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> on each call to subscribe and invokes all the
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>before</strong> the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterOnSubscribe&#8203;(java.util.function.Consumer&lt;? super <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>after</strong>
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterOnNext(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnNext</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterOnNext&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;onNext)</pre>
<div class="block">Invokes the <code>onNext</code> <code>Consumer</code> argument <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is
 called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  List&lt;T&gt; results = resultOfThisPublisher();
  nextOperation(results);
  for (T result : results) {
      onNext.accept(result);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onNext</code> - Invoked <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s
 of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    List&lt;T&gt; results = resultOfThisPublisher();
  } catch (Throwable cause) {
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterOnComplete(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterOnComplete&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>
 is called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
   List&lt;T&gt; results = resultOfThisPublisher();
   nextOperation(results);
   onComplete.run();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - Invoked <strong>after</strong> <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called for
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterRequest(java.util.function.LongConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterRequest</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterRequest&#8203;(java.util.function.LongConsumer&nbsp;onRequest)</pre>
<div class="block">Invokes the <code>onRequest</code> <code>LongConsumer</code> argument <strong>after</strong>
 <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onRequest</code> - Invoked <strong>after</strong> <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> is called for
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s
 of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>afterFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      List&lt;T&gt; results = resultOfThisPublisher();
  } finally {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s/<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      List&lt;T&gt; results = resultOfThisPublisher();
  } catch(Throwable t) {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes all the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> for each new subscribe and invokes all the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="whenSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> when the corresponding methods are called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> for each new subscribe and invokes methods on that
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> when the corresponding methods are called for <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterSubscription(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterSubscription</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;afterSubscription&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;subscriptionSupplier)</pre>
<div class="block">Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> (via the <code>subscriptionSupplier</code> argument) for each new subscribe and
 invokes all the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>after</strong> the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriptionSupplier</code> - Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> for each new subscribe and invokes all the
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>after</strong> the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="whenSubscription(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenSubscription</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;whenSubscription&#8203;(java.util.function.Supplier&lt;? extends <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscription</a>&gt;&nbsp;subscriptionSupplier)</pre>
<div class="block">Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> (via the <code>subscriptionSupplier</code> argument) for each new subscribe and
 invokes all the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods when the corresponding methods are called for <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s
 of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriptionSupplier</code> - Creates a new <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> for each new subscribe and invokes all the
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods when the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s of the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="forEach(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forEach</h4>
<pre class="methodSignature">public final&nbsp;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&nbsp;forEach&#8203;(java.util.function.Consumer&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;forEach)</pre>
<div class="block">Subscribes to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and invokes <code>forEach</code> <code>Consumer</code> for each item emitted by this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This will request <code>Long.MAX_VALUE</code> from the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  List&lt;T&gt; results = resultOfThisPublisher();
  results.iterator().forEachRemaining(forEach);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>forEach</code> - <code>Consumer</code> to invoke for each <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> used to invoke <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> on the parameter of
 <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> for this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishOn(io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;publishOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods.
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Only subsequent operations, if any, added in this execution chain
 will use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>publishOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a>, current operator always
 enforces offloading to the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>publishOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a></dd>
</dl>
</li>
</ul>
<a id="publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;publishOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
                                    java.util.function.BooleanSupplier&nbsp;shouldOffload)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods.
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Only subsequent operations, if any, added in this execution chain
 will use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#publishOn(io.servicetalk.concurrent.Executor)"><code>publishOn(io.servicetalk.concurrent.Executor)</code></a>, current operator may skip offloading to the
 passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>, depending on the result of the <code>BooleanSupplier</code> hint.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dd><code>shouldOffload</code> - Provides a hint whether offloading to the executor can be omitted or not. Offloading may
 still occur even if <code>false</code> is returned in order to preserve signal ordering.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> methods.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#publishOn(io.servicetalk.concurrent.Executor)"><code>publishOn(io.servicetalk.concurrent.Executor)</code></a></dd>
</dl>
</li>
</ul>
<a id="subscribeOn(io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;subscribeOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 <ul>
     <li>All <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>handleSubscribe(PublisherSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Only subsequent operations, if any, added in this execution chain
 will use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>subscribeOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a>, current operator always
 enforces offloading to the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 methods of <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>handleSubscribe(PublisherSource.Subscriber)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>subscribeOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a></dd>
</dl>
</li>
</ul>
<a id="subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;subscribeOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
                                      java.util.function.BooleanSupplier&nbsp;shouldOffload)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 <ul>
     <li>All <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>handleSubscribe(PublisherSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Only subsequent operations, if any, added in this execution chain
 will use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#subscribeOn(io.servicetalk.concurrent.Executor)"><code>subscribeOn(io.servicetalk.concurrent.Executor)</code></a>, current operator may skip offloading to
 the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>, depending on the result of the <code>BooleanSupplier</code>
 hint.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dd><code>shouldOffload</code> - Provides a hint whether offloading to the executor can be omitted or not. Offloading may
 still occur even if <code>false</code> is returned in order to preserve signal ordering.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 methods of <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>handleSubscribe(PublisherSource.Subscriber)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#subscribeOn(io.servicetalk.concurrent.Executor)"><code>subscribeOn(io.servicetalk.concurrent.Executor)</code></a></dd>
</dl>
</li>
</ul>
<a id="shareContextOnSubscribe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shareContextOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;shareContextOnSubscribe()</pre>
<div class="block">Signifies that when the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a>.
 <p>
 This operator only impacts behavior if the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed directly after this operator,
 that means this must be the "last operator" in the chain for this to have an impact.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that will share the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> instead of making a
 <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a> when subscribed to.</dd>
</dl>
</li>
</ul>
<a id="liftSync(io.servicetalk.concurrent.api.PublisherOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftSync</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;liftSync&#8203;(<a href="PublisherOperator.html" title="interface in io.servicetalk.concurrent.api">PublisherOperator</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <pre><code>
     Publisher&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftSync(original -&gt; modified)
        .filter(..) // B
 </code></pre>

 The <code>original -&gt; modified</code> "operator" <strong>MUST</strong> be "synchronous" in that it does not interact
 with the original <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> from outside the modified <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> or <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>
 threads. That is to say this operator will not impact the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> constraints already in place between
 <i>A</i> and <i>B</i> above. If you need asynchronous behavior, or are unsure, see
 <a href="#liftAsync(io.servicetalk.concurrent.api.PublisherOperator)"><code>liftAsync(PublisherOperator)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and the return is the "modified" <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftAsync(io.servicetalk.concurrent.api.PublisherOperator)"><code>liftAsync(PublisherOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="liftSyncToSingle(io.servicetalk.concurrent.api.PublisherToSingleOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftSyncToSingle</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;liftSyncToSingle&#8203;(<a href="PublisherToSingleOperator.html" title="interface in io.servicetalk.concurrent.api">PublisherToSingleOperator</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed, the <code>operator</code> argument will be used to convert between the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <pre><code>
     Publisher&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftSync(original -&gt; modified)
        .filter(..) // B - we have converted to Single now!
 </code></pre>

 The <code>original -&gt; modified</code> "operator" <strong>MUST</strong> be "synchronous" in that it does not interact
 with the original <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> from outside the modified <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> or <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>
 threads. That is to say this operator will not impact the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> constraints already in place between
 <i>A</i> and <i>B</i> above. If you need asynchronous behavior, or are unsure, don't use this operator.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and the return is the "modified" <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> that provides custom operator
 business logic on this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed, the <code>operator</code> argument will be used to convert the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to a <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
</dl>
</li>
</ul>
<a id="liftAsync(io.servicetalk.concurrent.api.PublisherOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftAsync</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;liftAsync&#8203;(<a href="PublisherOperator.html" title="interface in io.servicetalk.concurrent.api">PublisherOperator</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which will wrap the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> using the provided
 <code>operator</code> argument before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <pre><code>
     Publisher&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftAsync(original -&gt; modified)
        .filter(..) // B
 </code></pre>
 The <code>original -&gt; modified</code> "operator" MAY be "asynchronous" in that it may interact with the original
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> from outside the modified <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> or <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> threads. More
 specifically:
 <ul>
  <li>all of the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> invocations going "downstream" (i.e. from <i>A</i> to <i>B</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
  <li>all of the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> invocations going "upstream" (i.e. from <i>B</i> to <i>A</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
 </ul>
 This behavior exists to prevent blocking code negatively impacting the thread that powers the upstream source of
 data (e.g. an EventLoop).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and the return is the "modified" <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> before subscribing to this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftSync(io.servicetalk.concurrent.api.PublisherOperator)"><code>liftSync(PublisherOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="firstOrElse(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstOrElse</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;firstOrElse&#8203;(java.util.function.Supplier&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;defaultValueSupplier)</pre>
<div class="block">Converts this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>defaultValueSupplier</code> - A <code>Supplier</code> of default value if this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> did not emit any item.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will contain the first item emitted from the this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 If the source <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> does not emit any item, then the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will contain the value
 as returned by the passed <code>Supplier</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/first.html">ReactiveX first operator.</a></dd>
</dl>
</li>
</ul>
<a id="firstOrError()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstOrError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;firstOrError()</pre>
<div class="block">Ensures that this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits exactly a single <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> to its
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>. If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates without emitting any
 items a <code>NoSuchElementException</code> will be signaled and if this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits more than one item,
 an <code>IllegalArgumentException</code> will be signaled. Any error emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will be
 forwarded to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will contain the first item emitted from the this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 If the source <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> does not emit any item, then the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will terminate with
 <code>NoSuchElementException</code>.</dd>
</dl>
</li>
</ul>
<a id="ignoreElements()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignoreElements</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;ignoreElements()</pre>
<div class="block">Ignores all elements emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors the terminal signal from this <code>Publisher</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/ignoreelements.html">
     ReactiveX ignoreElements operator.</a></dd>
</dl>
</li>
</ul>
<a id="completableOrError()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completableOrError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;completableOrError()</pre>
<div class="block">Converts this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits any
 <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signals the resulting <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will be terminated with a
 <code>IllegalArgumentException</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors the terminal signal from this <code>Publisher</code>, and terminates in
 error if an <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signals.</dd>
</dl>
</li>
</ul>
<a id="collect(java.util.function.Supplier,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collect</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;collect&#8203;(java.util.function.Supplier&lt;? extends R&gt;&nbsp;resultFactory,
                                   java.util.function.BiFunction&lt;? super R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;collector)</pre>
<div class="block">Collects all items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a single item.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the reduced item.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultFactory</code> - Factory for the result which collects all items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 This will be called every time the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.</dd>
<dd><code>collector</code> - Invoked for every item emitted by the source <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and returns the same or altered
 <code>result</code> object.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that completes with the single <code>result</code> or any error emitted by the source
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX reduce operator.</a></dd>
</dl>
</li>
</ul>
<a id="toFuture()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toFuture</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.Future&lt;java.util.Collection&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;toFuture()</pre>
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>Future</code> with a <code>Collection</code> containing the elements of this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination. If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates in an error, then the
 intermediate <code>Collection</code> will be discarded and the <code>Future</code> will complete exceptionally.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Future</code> with a <code>Collection</code> containing the elements of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon
 successful termination.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#toFuture(java.util.function.Supplier,java.util.function.BiFunction)"><code>toFuture(Supplier, BiFunction)</code></a></dd>
</dl>
</li>
</ul>
<a id="toFuture(java.util.function.Supplier,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toFuture</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;java.util.concurrent.Future&lt;R&gt;&nbsp;toFuture&#8203;(java.util.function.Supplier&lt;? extends R&gt;&nbsp;resultFactory,
                                                         java.util.function.BiFunction&lt;? super R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;reducer)</pre>
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>Future</code> of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which represents all elements of this
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination. If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates in an error, then the
 intermediate <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will be discarded and the <code>Future</code> will complete exceptionally.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the reduced item.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultFactory</code> - Factory for the result which collects all items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>reducer</code> - Invoked for every item emitted by the source <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and returns the same or altered
 <code>result</code> object.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Future</code> of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which represents all elements of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon
 successful termination.</dd>
</dl>
</li>
</ul>
<a id="toCompletionStage()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletionStage</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.CompletionStage&lt;java.util.Collection&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&gt;&nbsp;toCompletionStage()</pre>
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>CompletionStage</code> with a <code>Collection</code> containing the elements
 of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination. If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates in an error, then the
 intermediate <code>Collection</code> will be discarded and the <code>CompletionStage</code> will complete exceptionally.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>CompletionStage</code> with a <code>Collection</code> containing the elements of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 upon successful termination.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#toCompletionStage(java.util.function.Supplier,java.util.function.BiFunction)"><code>toCompletionStage(Supplier, BiFunction)</code></a></dd>
</dl>
</li>
</ul>
<a id="toCompletionStage(java.util.function.Supplier,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletionStage</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;java.util.concurrent.CompletionStage&lt;R&gt;&nbsp;toCompletionStage&#8203;(java.util.function.Supplier&lt;? extends R&gt;&nbsp;resultFactory,
                                                                           java.util.function.BiFunction&lt;? super R,&#8203;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;R&gt;&nbsp;reducer)</pre>
<div class="block">Convert this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> into a <code>CompletionStage</code> of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which represents all elements of
 this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon successful termination. If this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates in an error, then the
 intermediate <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will be discarded and the <code>CompletionStage</code> will complete exceptionally.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the reduced item.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultFactory</code> - Factory for the result which collects all items emitted by this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>reducer</code> - Invoked for every item emitted by the source <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and returns the same or altered
 <code>result</code> object.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>CompletionStage</code> of type <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> which represents all elements of this <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> upon
 successful termination.</dd>
</dl>
</li>
</ul>
<a id="toInputStream(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toInputStream</h4>
<pre class="methodSignature">public final&nbsp;java.io.InputStream&nbsp;toInputStream&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;byte[]&gt;&nbsp;serializer)</pre>
<div class="block">Subscribes to <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and converts all signals received by the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to the
 returned <code>InputStream</code> following the below rules:
 <ul>
     <li><a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> received by <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is used to
     request more data when required. If the returned <code>InputStream</code> is closed, <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> is
     cancelled and any unread data is disposed.</li>
     <li>Any items received by <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> are converted to a <code>byte[]</code> using the
     passed <code>serializer</code>. These <code>byte</code>s are available to be read from the <code>InputStream</code></li>
     <li>Any <code>Throwable</code> received by <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is thrown (wrapped in an
     <code>IOException</code>) when data is read from the returned <code>InputStream</code>. This error will be thrown
     only after draining all queued data, if any.</li>
     <li>When <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called, returned <code>InputStream</code>'s read methods will return
     <code>-1</code> to indicate end of stream after emitting all received data.</li>
 </ul>

 <p><strong>Flow control</strong></p>
 This operator may pre-fetch may pre-fetch items from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if available to reduce
 blocking for read operations from the returned <code>InputStream</code>. In order to increase responsiveness of the
 <code>InputStream</code> some amount of buffering may be done. Use <a href="#toInputStream(java.util.function.Function,int)"><code>toInputStream(Function, int)</code></a> to manage
 capacity of this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>serializer</code> - <code>Function</code> that is invoked for every item emitted by <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>InputStream</code> that emits all data emitted by <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. If <code>this</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates with an error, same error is thrown (wrapped in an <code>IOException</code>) from the
 returned <code>InputStream</code>s read methods after emitting all received data.</dd>
</dl>
</li>
</ul>
<a id="toInputStream(java.util.function.Function,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toInputStream</h4>
<pre class="methodSignature">public final&nbsp;java.io.InputStream&nbsp;toInputStream&#8203;(java.util.function.Function&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>,&#8203;byte[]&gt;&nbsp;serializer,
                                               int&nbsp;queueCapacity)</pre>
<div class="block">Subscribes to <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and converts all signals received by the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to the
 returned <code>InputStream</code> following the below rules:
 <ul>
     <li><a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> received by <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is used to
     request more data when required. If the returned <code>InputStream</code> is closed, <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> is
     cancelled and any unread data is disposed.</li>
     <li>Any items received by <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> are converted to a <code>byte[]</code> using the
     passed <code>serializer</code>. These <code>byte</code>s are available to be read from the <code>InputStream</code></li>
     <li>Any <code>Throwable</code> received by <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is thrown (wrapped in an
     <code>IOException</code>) when data is read from the returned <code>InputStream</code>. This error will be thrown
     only after draining all queued data, if any.</li>
     <li>When <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called, returned <code>InputStream</code>'s read methods will return
     <code>-1</code> to indicate end of stream after emitting all received data.</li>
 </ul>

 <p><strong>Flow control</strong></p>
 This operator may pre-fetch items from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if available to reduce blocking for read
 operations from the returned <code>InputStream</code>. In order to increase responsiveness of the <code>InputStream</code>
 some amount of buffering may be done. <code>queueCapacity</code> can be used to bound this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>serializer</code> - <code>Function</code> that is invoked for every item emitted by <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dd><code>queueCapacity</code> - Hint for the capacity of the intermediary queue that stores items that are emitted by
 <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but has not yet been read from the returned <code>InputStream</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>InputStream</code> that emits all data emitted by <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. If <code>this</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates with an error, same error is thrown (wrapped in an <code>IOException</code>) from the
 returned <code>InputStream</code>s read methods after emitting all received data.</dd>
</dl>
</li>
</ul>
<a id="toIterable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toIterable</h4>
<pre class="methodSignature">public final&nbsp;<a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent">BlockingIterable</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;toIterable()</pre>
<div class="block">Converts <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to an <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>. Every time
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> is called on the returned <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>, <code>this</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed following the below rules:
 <ul>
     <li><a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> received by <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is used to
     request more data when required.</li>
     <li>Any items received by <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is returned from a call to
     <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a>.</li>
     <li>Any <code>Throwable</code> received by <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is thrown (wrapped in a
     <code>RuntimeException</code> if required) when <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a> is called. This error will be
     thrown only after draining all queued data, if any.</li>
     <li>When <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called, returned <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>s
     <code>Iterator.hasNext()</code> will return <code>false</code> <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a> will throw
     <code>NoSuchElementException</code>. This error will be thrown only after draining all queued data, if any.</li>
 </ul>

 <p><strong>Flow control</strong></p>
 This operator may pre-fetch items from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if available to reduce blocking of
 <code>Iterator.hasNext()</code> from the returned <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>. In order to increase responsiveness of
 the <code>Iterator</code> some amount of buffering may be done. Use <a href="#toIterable(int)"><code>toIterable(int)</code></a> to manage capacity of
 this buffer.

 <p><strong>Blocking</strong></p>
 The returned <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a> from the returned <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> will block on
 <code>Iterator.hasNext()</code> and <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a> if no data is available. This operator may
 try to reduce this blocking by requesting data ahead of time.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> representing <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Every time
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> is invoked on the <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>, <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 is subscribed. <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>s returned from this <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> do not support
 <code>Iterator.remove()</code>.</dd>
</dl>
</li>
</ul>
<a id="toIterable(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toIterable</h4>
<pre class="methodSignature">public final&nbsp;<a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent">BlockingIterable</a>&lt;<a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;toIterable&#8203;(int&nbsp;queueCapacityHint)</pre>
<div class="block">Converts <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to an <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>. Every time
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> is called on the returned <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>, <code>this</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed following the below rules:
 <ul>
     <li><a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> received by <a href="../PublisherSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.PublisherSource.Subscription)"><code>PublisherSource.Subscriber.onSubscribe(PublisherSource.Subscription)</code></a> is used to
     request more data when required.</li>
     <li>Any items received by <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> is returned from a call to
     <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a>.</li>
     <li>Any <code>Throwable</code> received by <a href="../PublisherSource.Subscriber.html#onError(java.lang.Throwable)"><code>PublisherSource.Subscriber.onError(Throwable)</code></a> is thrown (wrapped in a
     <code>RuntimeException</code> if required) when <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a>. This error will be thrown
      only after draining all queued data, if any.</li>
     <li>When <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a> is called, returned <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>s
     <code>Iterator.hasNext()</code> will return <code>false</code> and <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a> will throw
     <code>NoSuchElementException</code>. This error will be thrown only after draining all queued data, if any.</li>
 </ul>

 <p><strong>Flow control</strong></p>
 This operator may pre-fetch items from <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> if available to reduce blocking of
 <code>Iterator.hasNext()</code> from the returned <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>. In order to increase
 responsiveness of the <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a> some amount of buffering may be done. <code>queueCapacityHint</code>
 can be used to bound this buffer.

 <p><strong>Blocking</strong></p>
 The returned <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a> from the returned <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> will block on
 <code>Iterator.hasNext()</code> and <a href="../BlockingIterator.html#next()"><code>BlockingIterator.next()</code></a> if no data is available. This operator may
 try to reduce this blocking by requesting data ahead of time.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>queueCapacityHint</code> - Hint for the capacity of the intermediary queue that stores items that are emitted by
 <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> but has not yet been returned from the <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> representing <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Every time
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> is invoked on the <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a>, <code>this</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 is subscribed. <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>s returned from this <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> do not support
 <code>Iterator.remove()</code>.</dd>
</dl>
</li>
</ul>
<a id="subscribeInternal(io.servicetalk.concurrent.PublisherSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeInternal</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;subscribeInternal&#8203;(<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;subscriber)</pre>
<div class="block">A internal subscribe method similar to <a href="../PublisherSource.html#subscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)"><code>PublisherSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> to subscribe for the result.</dd>
</dl>
</li>
</ul>
<a id="handleSubscribe(io.servicetalk.concurrent.PublisherSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleSubscribe</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;handleSubscribe&#8203;(<a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent">PublisherSource.Subscriber</a>&lt;? super <a href="Publisher.html" title="type parameter in Publisher">T</a>&gt;&nbsp;subscriber)</pre>
<div class="block">Handles a subscriber to this <code>Publisher</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - the subscriber.</dd>
</dl>
</li>
</ul>
<a id="from(java.lang.Object)">
<!--   -->
</a><a id="from(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;from&#8203;(@Nullable
                                    T&nbsp;value)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>value</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - Value that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>value</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/just.html">ReactiveX just operator.</a></dd>
</dl>
</li>
</ul>
<a id="from(java.lang.Object,java.lang.Object)">
<!--   -->
</a><a id="from(T,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;from&#8203;(@Nullable
                                    T&nbsp;v1,
                                    @Nullable
                                    T&nbsp;v2)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>v1</code> and <code>v2</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v1</code> - The first value that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dd><code>v2</code> - The second value that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>v1</code> and <code>v2</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/just.html">ReactiveX just operator.</a></dd>
</dl>
</li>
</ul>
<a id="from(java.lang.Object,java.lang.Object,java.lang.Object)">
<!--   -->
</a><a id="from(T,T,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;from&#8203;(@Nullable
                                    T&nbsp;v1,
                                    @Nullable
                                    T&nbsp;v2,
                                    @Nullable
                                    T&nbsp;v3)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>v1</code>, <code>v2</code>, and <code>v3</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and
 then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v1</code> - The first value that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dd><code>v2</code> - The second value that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dd><code>v3</code> - The third value that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits <code>v1</code>, <code>v2</code>, and <code>v3</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and
 then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/just.html">ReactiveX just operator.</a></dd>
</dl>
</li>
</ul>
<a id="from(java.lang.Object[])">
<!--   -->
</a><a id="from(T...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;from&#8203;(T...&nbsp;values)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all <code>values</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>values</code> - Values that the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will emit.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all <code>values</code> to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/from.html">ReactiveX from operator.</a></dd>
</dl>
</li>
</ul>
<a id="fromIterable(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromIterable</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;fromIterable&#8203;(java.lang.Iterable&lt;? extends T&gt;&nbsp;iterable)</pre>
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will get an <code>Iterator</code> via <code>Iterable.iterator()</code>
 and emit all values to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.
 <p>
 The Reactive Streams specification provides two criteria (
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.4">3.4</a>, and
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.5">3.5</a>) stating
 the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> should be "responsive". The responsiveness of the associated <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s will
 depend upon the behavior of the <code>iterable</code> below. Make sure the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> for this execution chain
 can tolerate this responsiveness and any blocking behavior.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iterable</code> - used to obtain instances of <code>Iterator</code> to extract data from. <code>Iterable.iterator()</code>
 must not return <code>null</code>. If this is of type <a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterable</code></a> then any generated
 <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>s will have their <a href="../BlockingIterator.html#close()"><code>BlockingIterator.close()</code></a> method called if an error
 occurs.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will get an <code>Iterator</code> via <code>Iterable.iterator()</code>
 and emit all values to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromBlockingIterable(io.servicetalk.concurrent.BlockingIterable,java.util.function.LongSupplier,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromBlockingIterable</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;fromBlockingIterable&#8203;(<a href="../BlockingIterable.html" title="interface in io.servicetalk.concurrent">BlockingIterable</a>&lt;? extends T&gt;&nbsp;iterable,
                                                    java.util.function.LongSupplier&nbsp;timeoutSupplier,
                                                    java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will get a <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a> via
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> and emit all values to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.
 <p>
 The Reactive Streams specification provides two criteria (
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.4">3.4</a>, and
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.5">3.5</a>) stating
 the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> should be "responsive". The responsiveness of the associated <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s will
 depend upon the behavior of the <code>iterable</code> below. Make sure the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> for this execution chain
 can tolerate this responsiveness and any blocking behavior.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iterable</code> - used to obtain instances of <code>Iterator</code> to extract data from. <code>Iterable.iterator()</code>
 must not return <code>null</code>. Any generated <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a>s will have their
 <a href="../BlockingIterator.html#close()"><code>BlockingIterator.close()</code></a> method called if an error occurs.</dd>
<dd><code>timeoutSupplier</code> - A <code>LongSupplier</code> which provides the time duration to wait for each
 interaction with <code>iterable</code>.</dd>
<dd><code>unit</code> - The time units for the <code>timeout</code> duration.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will get a <a href="../BlockingIterator.html" title="interface in io.servicetalk.concurrent"><code>BlockingIterator</code></a> via
 <a href="../BlockingIterable.html#iterator()"><code>BlockingIterable.iterator()</code></a> and emit all values to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then
 <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromInputStream(java.io.InputStream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromInputStream</h4>
<pre class="methodSignature">public static&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;byte[]&gt;&nbsp;fromInputStream&#8203;(java.io.InputStream&nbsp;stream)</pre>
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all data from the <code>InputStream</code> to the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.
 <p>
 The Reactive Streams specification provides two criteria (
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.4">3.4</a>, and
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.5">3.5</a>) stating
 the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> should be "responsive". The responsiveness of the associated <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s will
 depend upon the behavior of the <code>stream</code> below. Make sure the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> for this execution chain
 can tolerate this responsiveness and any blocking behavior.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stream</code> - provides the data in the form of <code>byte[]</code> to be emitted to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> by the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Given the blocking nature of <code>InputStream</code>, assume <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> can block when the underlying <code>InputStream</code> blocks on <code>InputStream.read(byte[], int, int)</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all data from the <code>InputStream</code> to the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromInputStream(java.io.InputStream,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromInputStream</h4>
<pre class="methodSignature">public static&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;byte[]&gt;&nbsp;fromInputStream&#8203;(java.io.InputStream&nbsp;stream,
                                                int&nbsp;readChunkSize)</pre>
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all data from the <code>InputStream</code> to the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.
 <p>
 The Reactive Streams specification provides two criteria (
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.4">3.4</a>, and
 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.5">3.5</a>) stating
 the <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a> should be "responsive". The responsiveness of the associated <a href="../PublisherSource.Subscription.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscription</code></a>s will
 depend upon the behavior of the <code>stream</code> below. Make sure the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> for this execution chain
 can tolerate this responsiveness and any blocking behavior.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stream</code> - provides the data in the form of <code>byte[]</code> to be emitted to the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> by the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Given the blocking nature of <code>InputStream</code>, assume <a href="../PublisherSource.Subscription.html#request(long)"><code>PublisherSource.Subscription.request(long)</code></a> can block when the underlying <code>InputStream</code> blocks on <code>InputStream.read(byte[], int, int)</code>.</dd>
<dd><code>readChunkSize</code> - the maximum length of <code>byte[]</code> chunks which will be read from the <code>InputStream</code>
 and emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all data from the <code>InputStream</code> to the
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and then <a href="../PublisherSource.Subscriber.html#onComplete()"><code>PublisherSource.Subscriber.onComplete()</code></a>.</dd>
</dl>
</li>
</ul>
<a id="range(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>range</h4>
<pre class="methodSignature">public static&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Integer&gt;&nbsp;range&#8203;(int&nbsp;begin,
                                                 int&nbsp;end)</pre>
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all <code>Integer</code>s within the range of
 [<code>begin</code>, <code>end</code>).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>begin</code> - The beginning of the range (inclusive).</dd>
<dd><code>end</code> - The end of the range (exclusive).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all <code>Integer</code>s within the range of
 [<code>begin</code>, <code>end</code>).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/range.html">Range.</a></dd>
</dl>
</li>
</ul>
<a id="range(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>range</h4>
<pre class="methodSignature">public static&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Integer&gt;&nbsp;range&#8203;(int&nbsp;begin,
                                                 int&nbsp;end,
                                                 int&nbsp;stride)</pre>
<div class="block">Create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all <code>Integer</code>s within the range of
 [<code>begin</code>, <code>end</code>) with an increment of <code>stride</code> between each signal.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>begin</code> - The beginning of the range (inclusive).</dd>
<dd><code>end</code> - The end of the range (exclusive).</dd>
<dd><code>stride</code> - The amount to increment in between each signal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that when subscribed will emit all <code>Integer</code>s within the range of
 [<code>begin</code>, <code>end</code>) with an increment of <code>stride</code> between each signal.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/range.html">Range.</a></dd>
</dl>
</li>
</ul>
<a id="empty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>empty</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;empty()</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that completes when subscribed without emitting any item to its
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that completes when subscribed without emitting any item to its
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX empty operator.</a></dd>
</dl>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;never()</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that never emits any item to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and never call any terminal
 methods on it.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that never emits any item to its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> and never call any terminal
 methods on it.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX never operator.</a></dd>
</dl>
</li>
</ul>
<a id="failed(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failed</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;failed&#8203;(java.lang.Throwable&nbsp;cause)</pre>
<div class="block">Creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that terminates its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> with an error without emitting any item to
 it.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cause</code> - The <code>Throwable</code> that is used to terminate the <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that terminates its <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a> with an error without emitting any item to
 it.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX error operator.</a></dd>
</dl>
</li>
</ul>
<a id="defer(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>defer</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;defer&#8203;(java.util.function.Supplier&lt;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&gt;&nbsp;publisherSupplier)</pre>
<div class="block">Defers creation of a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> till it is subscribed.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>publisherSupplier</code> - <code>Supplier</code> to create a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> every time the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is subscribed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that creates a new <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> using <code>publisherSupplier</code> every time
 it is subscribed and forwards all items and terminal events from the newly created <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to its
 <a href="../PublisherSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>PublisherSource.Subscriber</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/defer.html">ReactiveX defer operator.</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
