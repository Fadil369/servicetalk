<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Single</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Single";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":9,"i9":9,"i10":10,"i11":9,"i12":9,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":10,"i31":10,"i32":10,"i33":10,"i34":9,"i35":9,"i36":10,"i37":10,"i38":10,"i39":9,"i40":9,"i41":9,"i42":9,"i43":6,"i44":10,"i45":10,"i46":10,"i47":10,"i48":9,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":9,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9,"i92":9,"i93":9,"i94":10,"i95":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.servicetalk.concurrent.api</a></div>
<h2 title="Class Single" class="title">Class Single&lt;T&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.servicetalk.concurrent.api.Single&lt;T&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the single.</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="LegacyTestSingle.html" title="class in io.servicetalk.concurrent.api">LegacyTestSingle</a></code>, <code><a href="internal/SubscribableSingle.html" title="class in io.servicetalk.concurrent.api.internal">SubscribableSingle</a></code>, <code><a href="TestSingle.html" title="class in io.servicetalk.concurrent.api">TestSingle</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">Single&lt;T&gt;</span>
extends java.lang.Object</pre>
<div class="block">An asynchronous computation that either completes with success giving the result or completes with an error.

 <h2>How to subscribe?</h2>

 This class does not provide a way to subscribe using a <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> as such calls are
 ambiguous about the intent whether the subscribe is part of the same source (a.k.a an operator) or it is a terminal
 subscribe. If it is required to subscribe to a source, then a <a href="SourceAdapters.html" title="class in io.servicetalk.concurrent.api"><code>source adapter</code></a> can be used to
 convert to a <a href="../SingleSource.html" title="interface in io.servicetalk.concurrent"><code>SingleSource</code></a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colSecond" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Single</a></span>()</code></th>
<td class="colLast">
<div class="block">New instance.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterCancel(java.lang.Runnable)">afterCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">afterFinally</a></span>&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">afterFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(java.lang.Runnable)">afterFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnError(java.util.function.Consumer)">afterOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnSubscribe(java.util.function.Consumer)">afterOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnSuccess(java.util.function.Consumer)">afterOnSuccess</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterSubscriber(java.util.function.Supplier)">afterSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#amb(io.servicetalk.concurrent.api.Single...)">amb</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#amb(java.lang.Iterable)">amb</a></span>&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ambWith(io.servicetalk.concurrent.api.Single)">ambWith</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of either this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or the passed <code>other</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, whichever terminates first.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#anyOf(io.servicetalk.concurrent.api.Single...)">anyOf</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#anyOf(java.lang.Iterable)">anyOf</a></span>&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeCancel(java.lang.Runnable)">beforeCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">beforeFinally</a></span>&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">beforeFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(java.lang.Runnable)">beforeFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnError(java.util.function.Consumer)">beforeOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnSubscribe(java.util.function.Consumer)">beforeOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnSuccess(java.util.function.Consumer)">beforeOnSuccess</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeSubscriber(java.util.function.Supplier)">beforeSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cast(java.lang.Class)">cast</a></span>&#8203;(java.lang.Class&lt;R&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Cast this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> from type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(int,io.servicetalk.concurrent.api.Single...)">collectUnordered</a></span>&#8203;(int&nbsp;maxConcurrency,
                <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(io.servicetalk.concurrent.api.Single...)">collectUnordered</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(java.lang.Iterable)">collectUnordered</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(java.lang.Iterable,int)">collectUnordered</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(int,io.servicetalk.concurrent.api.Single...)">collectUnorderedDelayError</a></span>&#8203;(int&nbsp;maxConcurrency,
                          <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(io.servicetalk.concurrent.api.Single...)">collectUnorderedDelayError</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(java.lang.Iterable)">collectUnorderedDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(java.lang.Iterable,int)">collectUnorderedDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                          int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Completable)">concat</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 terminates successfully.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Publisher)">concat</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits all
 elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Publisher,boolean)">concat</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next,
      boolean&nbsp;deferSubscribe)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits all
 elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Single)">concat</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#defer(java.util.function.Supplier)">defer</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singleSupplier)</code></th>
<td class="colLast">
<div class="block">Defer creation of a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> till it is subscribed to.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failed(java.lang.Throwable)">failed</a></span>&#8203;(java.lang.Throwable&nbsp;cause)</code></th>
<td class="colLast">
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes with the provided error <code>cause</code>.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMap(java.util.function.Function)">flatMap</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that mirrors emissions from the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>next</code>.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletable(java.util.function.Function)">flatMapCompletable</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors emissions from the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>next</code>.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapPublisher(java.util.function.Function)">flatMapPublisher</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that mirrors emissions from the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by <code>next</code>.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromCallable(java.util.concurrent.Callable)">fromCallable</a></span>&#8203;(java.util.concurrent.Callable&lt;T&gt;&nbsp;callable)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Callable.call()</code> on the passed
 <code>Callable</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFuture(java.util.concurrent.Future)">fromFuture</a></span>&#8203;(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block">Convert from a <code>Future</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> via <code>Future.get()</code>.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromStage(java.util.concurrent.CompletionStage)">fromStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;? extends T&gt;&nbsp;stage)</code></th>
<td class="colLast">
<div class="block">Convert from a <code>CompletionStage</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromSupplier(java.util.function.Supplier)">fromSupplier</a></span>&#8203;(java.util.function.Supplier&lt;T&gt;&nbsp;supplier)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Supplier.get()</code> on the passed
 <code>Supplier</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)">handleSubscribe</a></span>&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">Handles a subscriber to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ignoreElement()">ignoreElement</a></span>()</code></th>
<td class="colLast">
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftAsync(io.servicetalk.concurrent.api.SingleOperator)">liftAsync</a></span>&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftSync(io.servicetalk.concurrent.api.SingleOperator)">liftSync</a></span>&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#map(java.util.function.Function)">map</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Maps the result of this single to a different type.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that never terminates.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.lang.Class,java.util.function.Function)">onErrorMap</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
          java.util.function.Function&lt;? super E,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>type</code> into a different error.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.util.function.Function)">onErrorMap</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into a different error.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.util.function.Predicate,java.util.function.Function)">onErrorMap</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
          java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>predicate</code> into a different error.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.lang.Class,java.util.function.Function)">onErrorResume</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
             java.util.function.Function&lt;? super E,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from errors emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>type</code> by using another <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 provided by the passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.util.function.Function)">onErrorResume</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the
 passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.util.function.Predicate,java.util.function.Function)">onErrorResume</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from errors emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>predicate</code> by using another
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorReturn(java.lang.Class,java.util.function.Function)">onErrorReturn</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
             java.util.function.Function&lt;? super E,&#8203;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;itemSupplier)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>type</code> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorReturn(java.util.function.Function)">onErrorReturn</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;itemSupplier)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal
 (e.g.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorReturn(java.util.function.Predicate,java.util.function.Function)">onErrorReturn</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;itemSupplier)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>predicate</code> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOn(io.servicetalk.concurrent.Executor)">publishOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">publishOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
         java.util.function.BooleanSupplier&nbsp;shouldOffload)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeat(java.util.function.IntPredicate)">repeat</a></span>&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the passed <code>IntPredicate</code> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeatWhen(java.util.function.IntFunction)">repeatWhen</a></span>&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(io.servicetalk.concurrent.api.BiIntPredicate)">retry</a></span>&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">retryWhen</a></span>&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shareContextOnSubscribe()">shareContextOnSubscribe</a></span>()</code></th>
<td class="colLast">
<div class="block">Signifies that when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a>.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribe(java.util.function.Consumer)">subscribe</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;resultConsumer)</code></th>
<td class="colLast">
<div class="block">Subscribe to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, emits the result to the passed <code>Consumer</code> and log any
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeInternal(io.servicetalk.concurrent.SingleSource.Subscriber)">subscribeInternal</a></span>&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">A internal subscribe method similar to <a href="../SingleSource.html#subscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>SingleSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOn(io.servicetalk.concurrent.Executor)">subscribeOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">subscribeOn</a></span>&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
           java.util.function.BooleanSupplier&nbsp;shouldOffload)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#succeeded(T)">succeeded</a></span>&#8203;(T&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes successfully with the provided <code>value</code>.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(long,java.util.concurrent.TimeUnit)">timeout</a></span>&#8203;(long&nbsp;duration,
       java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">timeout</a></span>&#8203;(long&nbsp;duration,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(java.time.Duration)">timeout</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(java.time.Duration,io.servicetalk.concurrent.Executor)">timeout</a></span>&#8203;(java.time.Duration&nbsp;duration,
       <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletable()">toCompletable</a></span>()</code></th>
<td class="colLast">
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletionStage()">toCompletionStage</a></span>()</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>CompletionStage</code>.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFuture()">toFuture</a></span>()</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>Future</code>.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toPublisher()">toPublisher</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <code>Single</code> to a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenCancel(java.lang.Runnable)">whenCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">whenFinally</a></span>&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">whenFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(java.lang.Runnable)">whenFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnError(java.util.function.Consumer)">whenOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnSubscribe(java.util.function.Consumer)">whenOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnSuccess(java.util.function.Consumer)">whenOnSuccess</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenSubscriber(java.util.function.Supplier)">whenSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> when the corresponding methods are called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of
 the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static &lt;T1,&#8203;T2,&#8203;T3,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zip(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function3)">zip</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
   <a href="Function3.html" title="interface in io.servicetalk.concurrent.api">Function3</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function3.html" title="interface in io.servicetalk.concurrent.api"><code>Function3</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, and <code>s3</code>.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static &lt;T1,&#8203;T2,&#8203;T3,&#8203;T4,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zip(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function4)">zip</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T4&gt;&nbsp;s4,
   <a href="Function4.html" title="interface in io.servicetalk.concurrent.api">Function4</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? super T4,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function4.html" title="interface in io.servicetalk.concurrent.api"><code>Function4</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code>.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static &lt;T1,&#8203;T2,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zip(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">zip</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
   java.util.function.BiFunction&lt;? super T1,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted
 by <code>s1</code> and <code>s2</code>.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zip(java.util.function.Function,io.servicetalk.concurrent.api.Single...)">zip</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Object[],&#8203;? extends R&gt;&nbsp;zipper,
   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;?&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>Function</code> to items emitted by
 <code>singles</code>.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>static &lt;T1,&#8203;T2,&#8203;T3,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipDelayError(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function3)">zipDelayError</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
             <a href="Function3.html" title="interface in io.servicetalk.concurrent.api">Function3</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function3.html" title="interface in io.servicetalk.concurrent.api"><code>Function3</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, and <code>s3</code>.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>static &lt;T1,&#8203;T2,&#8203;T3,&#8203;T4,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipDelayError(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function4)">zipDelayError</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T4&gt;&nbsp;s4,
             <a href="Function4.html" title="interface in io.servicetalk.concurrent.api">Function4</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? super T4,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function4.html" title="interface in io.servicetalk.concurrent.api"><code>Function4</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code>.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>static &lt;T1,&#8203;T2,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipDelayError(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">zipDelayError</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
             java.util.function.BiFunction&lt;? super T1,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted
 by <code>s1</code> and <code>s2</code>.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipDelayError(java.util.function.Function,io.servicetalk.concurrent.api.Single...)">zipDelayError</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Object[],&#8203;? extends R&gt;&nbsp;zipper,
             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;?&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>Function</code> to items emitted by
 <code>singles</code>.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>&lt;T2,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWith(io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">zipWith</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;other,
       java.util.function.BiFunction&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>this</code> and <code>other</code>.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>&lt;T2,&#8203;R&gt;<br><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithDelayError(io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">zipWithDelayError</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;other,
                 java.util.function.BiFunction&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>this</code> and <code>other</code>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Single</h4>
<pre>protected&nbsp;Single()</pre>
<div class="block">New instance.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="map(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>map</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;map&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;mapper)</pre>
<div class="block">Maps the result of this single to a different type. Error, if any is forwarded to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     R rResult = mapper.apply(tResult);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the returned <code>Single</code>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - To convert this result to other.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will now have the result of type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="cast(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cast</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;cast&#8203;(java.lang.Class&lt;R&gt;&nbsp;clazz)</pre>
<div class="block">Cast this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> from type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     R rResult = clazz.cast(tResult);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The resulting type of the cast operation.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - The type to cast to.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cast of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Terminates with a <code>ClassCastException</code> if
 signals cannot be cast to type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://reactivex.io/documentation/operators/map.html">ReactiveX cast operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorReturn(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorReturn&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;itemSupplier)</pre>
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal
 (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T result = resultOfThisSingle();
     try {
         terminalOfThisSingle();
     } catch (Throwable cause) {
         return itemSupplier.apply(cause);
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>itemSupplier</code> - returns the element to emit to <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorReturn(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorReturn&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                     java.util.function.Function&lt;? super E,&#8203;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;itemSupplier)</pre>
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>type</code> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T result = resultOfThisSingle();
     try {
         terminalOfThisSingle();
     } catch (Throwable cause) {
         if (!type.isInstance(cause)) {
           throw cause;
         }
         return itemSupplier.apply(cause);
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>itemSupplier</code> - returns the element to emit to <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorReturn(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorReturn&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                     java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;itemSupplier)</pre>
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>predicate</code> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T result = resultOfThisSingle();
     try {
         terminalOfThisSingle();
     } catch (Throwable cause) {
         if (!predicate.test(cause)) {
           throw cause;
         }
         return itemSupplier.apply(cause);
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed to
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal. Returns <code>false</code> to propagate the error.</dd>
<dd><code>itemSupplier</code> - returns the element to emit to <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorMap&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T result = resultOfThisSingle();
     try {
         terminalOfThisSingle();
     } catch (Throwable cause) {
         throw mapper.apply(cause);
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorMap&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                  java.util.function.Function&lt;? super E,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>type</code> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T result = resultOfThisSingle();
     try {
         terminalOfThisSingle();
     } catch (Throwable cause) {
         if (type.isInstance(cause)) {
           throw mapper.apply(cause);
         } else {
           throw cause;
         }
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorMap&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                  java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>predicate</code> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T results = resultOfThisSingle();
     try {
         terminalOfThisSingle();
     } catch (Throwable cause) {
         if (predicate.test(cause)) {
           throw mapper.apply(cause);
         } else {
           throw cause;
         }
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed via <code>mapper</code>. Returns
 <code>false</code> to propagate the original error.</dd>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which transform errors emitted on this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorResume&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the
 passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     T result;
     try {
         result = resultOfThisSingle();
     } catch (Throwable cause) {
         // Note that nextFactory returning a error Single is like re-throwing (nextFactory shouldn't throw).
         result = nextFactory.apply(cause);
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextFactory</code> - Returns the next <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, when this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that recovers from an error from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the passed <code>nextFactory</code>.</dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorResume&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                     java.util.function.Function&lt;? super E,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from errors emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>type</code> by using another <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 provided by the passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     T result;
     try {
         result = resultOfThisSingle();
     } catch (Throwable cause) {
       if (type.isInstance(cause)) {
         // Note that nextFactory returning a error Single is like re-throwing (nextFactory shouldn't throw).
         result = nextFactory.apply(cause);
       } else {
           throw cause;
       }
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>nextFactory</code> - Returns the next <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, when this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that recovers from an error from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onErrorResume&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                     java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from errors emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which match <code>predicate</code> by using another
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     T result;
     try {
         result = resultOfThisSingle();
     } catch (Throwable cause) {
       if (predicate.test(cause)) {
         // Note that nextFactory returning a error Single is like re-throwing (nextFactory shouldn't throw).
         result = nextFactory.apply(cause);
       } else {
           throw cause;
       }
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed via <code>nextFactory</code>.
 Returns <code>false</code> to propagate the original error.</dd>
<dd><code>nextFactory</code> - Returns the next <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, when this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that recovers from an error from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="flatMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;flatMap&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that mirrors emissions from the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>next</code>.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is forwarded to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     R rResult = mapper.apply(tResult); // Asynchronous result is flatten into a value by this operator.
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the result of the resulting <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - Function to give the next <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that switches to the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>next</code> after this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 completes successfully.</dd>
</dl>
</li>
</ul>
<a id="flatMapCompletable(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletable</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletable&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors emissions from the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>next</code>.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is forwarded to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous with either complete/error status
 in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     mapper.apply(tResult); // Asynchronous result is flatten into a error or completion by this operator.
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - Function to give the next <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that switches to the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>next</code> after this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> completes successfully.</dd>
</dl>
</li>
</ul>
<a id="flatMapPublisher(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapPublisher</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapPublisher&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that mirrors emissions from the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by <code>next</code>.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     // Asynchronous result from mapper is flatten into collection of values.
     for (R rResult : mapper.apply(tResult)) {
          // process rResult
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of objects emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - Function to give the next <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that switches to the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by <code>next</code> after this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> completes successfully.</dd>
</dl>
</li>
</ul>
<a id="whenOnSuccess(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnSuccess</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenOnSuccess&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</pre>
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>onSuccess</code> will be invoked relative to <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnSuccess(java.util.function.Consumer)"><code>beforeOnSuccess(Consumer)</code></a> and
 <a href="#afterOnSuccess(java.util.function.Consumer)"><code>afterOnSuccess(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result = resultOfThisSingle();
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(result);
  onSuccess.accept(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSuccess</code> - Invoked when <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnSuccess(java.util.function.Consumer)"><code>beforeOnSuccess(Consumer)</code></a>, 
<a href="#afterOnSuccess(java.util.function.Consumer)"><code>afterOnSuccess(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>onError</code> will be invoked relative to <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a> and
 <a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    T result = resultOfThisSingle();
  } catch (Throwable cause) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked when <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a>, 
<a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a> and <a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      T result = resultOfThisSingle();
  } finally {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked exactly once, when any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a>, 
<a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a> and
 <a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a>, 
<a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenFinally&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>beforeFinally(SingleTerminalSignalConsumer)</code></a> and
 <a href="#afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>afterFinally(SingleTerminalSignalConsumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onSuccess(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>beforeFinally(SingleTerminalSignalConsumer)</code></a>, 
<a href="#afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>afterFinally(SingleTerminalSignalConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is undefined. If
 you need strict ordering see <a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a> and <a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a>, 
<a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="timeout(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;timeout&#8203;(long&nbsp;duration,
                               java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination. The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;timeout&#8203;(long&nbsp;duration,
                               java.util.concurrent.TimeUnit&nbsp;unit,
                               <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination. The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use for managing the timer
 notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;timeout&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination. The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will via <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(java.time.Duration,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;timeout&#8203;(java.time.Duration&nbsp;duration,
                               <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use for managing the timer
 notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Single)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is
 forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     Pair&lt;T, T&gt; p = new Pair&lt;&gt;();
     p.first = resultOfThisSingle();
     p.second = nextSingle();
     return p;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to concat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</pre>
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 terminates successfully.
 <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will only be subscribed to after this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> terminates successfully.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is forwarded to the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     T result = resultOfThisSingle();
     nextCompletable(); // Note this either completes successfully, or throws an error.
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to concat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 terminates successfully.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits all
 elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 Note: this method is an overload for <a href="#concat(io.servicetalk.concurrent.api.Publisher,boolean)"><code>concat(Publisher, boolean)</code></a> with <code>deferSubscribe</code> equal to
 <code>false</code>, which triggers subscribe to the <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> as soon as <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> completes successfully.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     results.add(resultOfThisSingle());
     results.addAll(nextStream());
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to concat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 all elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#concat(io.servicetalk.concurrent.api.Publisher,boolean)"><code>concat(Publisher, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Publisher,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next,
                                 boolean&nbsp;deferSubscribe)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits all
 elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     results.add(resultOfThisSingle());
     results.addAll(nextStream());
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to concat.</dd>
<dd><code>deferSubscribe</code> - if <code>true</code> subscribe to the <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> will be deferred until
 demand is received. Otherwise, it subscribes to the <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> as soon as <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> completes successfully. Choosing the deferred (<code>true</code>) behavior is important if the
 <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> does not or might not support multiple subscribers (non-replayable). Choosing the
 immediate subscribe (<code>false</code>) behavior may have better performance and may be a preferable choice for
 replayable <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>(s) or when eager subscribe is beneficial.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 all elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
</dl>
</li>
</ul>
<a id="zipWith(io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWith</h4>
<pre class="methodSignature">public final&nbsp;&lt;T2,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zipWith&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;other,
                                            java.util.function.BiFunction&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>this</code> and <code>other</code>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T&gt; f1 = ...; // this
      CompletableFuture&lt;T2&gt; other = ...;
      CompletableFuture.allOf(f1, other).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), other.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T2</code> - The type of <code>other</code>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip with.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>this</code> and <code>other</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zipWithDelayError(io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;T2,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zipWithDelayError&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;other,
                                                      java.util.function.BiFunction&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>this</code> and <code>other</code>. If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated,
 and then terminate with the first error.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T&gt; f1 = ...; // this
      CompletableFuture&lt;T2&gt; other = ...;
      CompletableFuture.allOf(f1, other).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), other.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T2</code> - The type of <code>other</code>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip with.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>this</code> and <code>other</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="retry(io.servicetalk.concurrent.api.BiIntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;retry&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>retryWhen((i, cause) -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to retry an operation under certain failure conditions and in sequential programming
 is similar to:
 <pre><code>
     public T execute() {
         return execute(0);
     }

     private T execute(int attempts) {
         try {
             return resultOfThisSingle();
         } catch (Throwable cause) {
             if (shouldRetry.apply(attempts + 1, cause)) {
                 return execute(attempts + 1);
             } else {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRetry</code> - <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> that given the retry count and the most recent <code>Throwable</code>
 emitted from this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> determines if the operation should be retried.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or re-subscribes if an error is emitted
 and if the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returned <code>true</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retryWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;retryWhen&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> terminates with that error.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>retryWhen((i, cause) -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to retry an operation under certain failure conditions in an asynchronous fashion
 and in sequential programming is similar to:
 <pre><code>
     public T execute() {
         return execute(0);
     }

     private T execute(int attempts) {
         try {
             return resultOfThisSingle();
         } catch (Throwable cause) {
             try {
                 shouldRetry.apply(attempts + 1, cause); // Either throws or completes normally
                 execute(attempts + 1);
             } catch (Throwable ignored) {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>retryWhen</code> - <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> that given the retry count and the most recent <code>Throwable</code> emitted
 from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, that error is
 emitted from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, otherwise, original <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is re-subscribed when this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or re-subscribes if an error is emitted
 and <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeat(java.util.function.IntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;repeat&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the passed <code>IntPredicate</code> returns <code>true</code>.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>repeatWhen(i -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to repeat an operation multiple times and in sequential programming is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     int i = 0;
     do {
         results.add(resultOfThisSingle());
     } while (shouldRepeat.test(++i));
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRepeat</code> - <code>IntPredicate</code> that given the repeat count determines if the operation should be
 repeated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and from all re-subscriptions whenever
 the operation is repeated.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX repeat operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeatWhen(java.util.function.IntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeatWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;repeatWhen&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> emits an error.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>repeatWhen(i -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to repeat an operation multiple times when in an asynchronous fashion and in
 sequential programming is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     int i = 0;
     while (true) {
         results.add(resultOfThisSingle());
         try {
             repeatWhen.apply(++i); // Either throws or completes normally
         } catch (Throwable cause) {
             break;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>repeatWhen</code> - <code>IntFunction</code> that given the repeat count returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error repeat is terminated, otherwise, original <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is
 re-subscribed when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and from all re-subscriptions whenever
 the operation is repeated.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>before</strong> <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeOnSuccess(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnSuccess</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeOnSuccess&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</pre>
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result = resultOfThisSingle();
  onSuccess.accept(result);
  nextOperation(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSuccess</code> - Invoked <strong>before</strong> <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    T result = resultOfThisSingle();
  } catch (Throwable cause) {
      onError.accept(cause);
      nextOperation(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>before</strong> <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      T result = resultOfThisSingle();
  } finally {
      doFinally.run();
      nextOperation(); // Maybe notifying of cancellation, or termination
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      doFinally.onError(t);
      nextOperation(); // Maybe notifying of cancellation, or termination
      return;
  }
  doFinally.onComplete();
  nextOperation(); // Maybe notifying of cancellation, or termination
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeFinally&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      doFinally.onError(t);
      nextOperation(); // Maybe notifying of cancellation, or termination
      return;
  }
  doFinally.onSuccess(result);
  nextOperation(); // Maybe notifying of cancellation, or termination
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>after</strong> <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="whenOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.

 <p>
 The order in which <code>onSubscribe</code> will be invoked relative to
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is undefined. If you need strict ordering see
 <a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a> and <a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked when <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a>, 
<a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="afterOnSuccess(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnSuccess</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterOnSuccess&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</pre>
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result = resultOfThisSingle();
  nextOperation(result);
  onSuccess.accept(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSuccess</code> - Invoked <strong>after</strong> <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    T result = resultOfThisSingle();
  } catch (Throwable cause) {
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>after</strong> <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      T result = resultOfThisSingle();
  } finally {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterFinally&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onSuccess(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="whenSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> when the corresponding methods are called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of
 the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> for each new subscribe and invokes methods on that
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> when the corresponding methods are called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishOn(io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;publishOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods. This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will
 use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>publishOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a>, current operator always
 enforces offloading to the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>publishOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a></dd>
</dl>
</li>
</ul>
<a id="publishOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;publishOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
                                 java.util.function.BooleanSupplier&nbsp;shouldOffload)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will
 use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#publishOn(io.servicetalk.concurrent.Executor)"><code>publishOn(io.servicetalk.concurrent.Executor)</code></a>, current operator may skip offloading to the
 passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>,
 depending on the result of the <code>BooleanSupplier</code> hint.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dd><code>shouldOffload</code> - Provides a hint whether offloading to the executor can be omitted or not. Offloading may
 still occur even if <code>false</code> is returned in order to preserve signal ordering.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#publishOn(io.servicetalk.concurrent.Executor)"><code>publishOn(io.servicetalk.concurrent.Executor)</code></a></dd>
</dl>
</li>
</ul>
<a id="subscribeOn(io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscribeOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 <ul>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will
 use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>subscribeOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a>, current operator always
 enforces offloading to the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 methods of <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)"><code>subscribeOn(io.servicetalk.concurrent.Executor, BooleanSupplier)</code></a></dd>
</dl>
</li>
</ul>
<a id="subscribeOn(io.servicetalk.concurrent.Executor,java.util.function.BooleanSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscribeOn&#8203;(<a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;executor,
                                   java.util.function.BooleanSupplier&nbsp;shouldOffload)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke the
 following methods:
 <ul>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>s, if any,
 specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will
 use this <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>.
 <p>
 Note: unlike <a href="#subscribeOn(io.servicetalk.concurrent.Executor)"><code>subscribeOn(io.servicetalk.concurrent.Executor)</code></a>, current operator may skip offloading to
 the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a>, depending on the result of the <code>BooleanSupplier</code>
 hint.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to use.</dd>
<dd><code>shouldOffload</code> - Provides a hint whether offloading to the executor can be omitted or not. Offloading may
 still occur even if <code>false</code> is returned in order to preserve signal ordering.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that may use the passed <a href="../Executor.html" title="interface in io.servicetalk.concurrent"><code>Executor</code></a> to invoke all
 methods of <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#subscribeOn(io.servicetalk.concurrent.Executor)"><code>subscribeOn(io.servicetalk.concurrent.Executor)</code></a></dd>
</dl>
</li>
</ul>
<a id="shareContextOnSubscribe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shareContextOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;shareContextOnSubscribe()</pre>
<div class="block">Signifies that when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a>.
 <p>
 This operator only impacts behavior if the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed directly after this operator,
 that means this must be the "last operator" in the chain for this to have an impact.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will share the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> instead of making a
 <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a> when subscribed to.</dd>
</dl>
</li>
</ul>
<a id="liftSync(io.servicetalk.concurrent.api.SingleOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftSync</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;liftSync&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which will wrap the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> using the provided <code>operator</code>
 argument before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <pre><code>
     Single&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftSync(original -&gt; modified)
        .afterFinally(..) // B
 </code></pre>
 The <code>original -&gt; modified</code> "operator" <strong>MUST</strong> be "synchronous" in that it does not interact
 with the original <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> from outside the modified <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> or <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a>
 threads. That is to say this operator will not impact the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> constraints already in place between
 <i>A</i> and <i>B</i> above. If you need asynchronous behavior, or are unsure, see
 <a href="#liftAsync(io.servicetalk.concurrent.api.SingleOperator)"><code>liftAsync(SingleOperator)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and the return is the "modified" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftAsync(io.servicetalk.concurrent.api.SingleOperator)"><code>liftAsync(SingleOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="liftAsync(io.servicetalk.concurrent.api.SingleOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftAsync</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;liftAsync&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which will wrap the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> using the provided <code>operator</code>
 argument before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <pre><code>
     Publisher&lt;X&gt; pub = ...;
     pub.map(..) // Aw
        .liftAsync(original -&gt; modified)
        .afterFinally(..) // B
 </code></pre>
 The <code>original -&gt; modified</code> "operator" MAY be "asynchronous" in that it may interact with the original
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> from outside the modified <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> or <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> threads. More
 specifically:
 <ul>
  <li>all of the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> invocations going "downstream" (i.e. from <i>A</i> to <i>B</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
  <li>all of the <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> invocations going "upstream" (i.e. from <i>B</i> to <i>A</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
 </ul>
 This behavior exists to prevent blocking code negatively impacting the thread that powers the upstream source of
 data (e.g. an EventLoop).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and the return is the "modified" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftSync(io.servicetalk.concurrent.api.SingleOperator)"><code>liftSync(SingleOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="ambWith(io.servicetalk.concurrent.api.Single)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ambWith</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;ambWith&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;other)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of either this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or the passed <code>other</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, whichever terminates first. Therefore the result is
 said to be <strong>ambiguous</strong> relative to which source it originated from. After the first source
 terminates the non-terminated source will be cancelled.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from either of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to subscribe to and race with this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to propagate to the return value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of either this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or the passed <code>other</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, whichever terminates first. Therefore the result is
 said to be <strong>ambiguous</strong> relative to which source it originated from.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="toPublisher()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toPublisher</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;toPublisher()</pre>
<div class="block">Converts this <code>Single</code> to a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits at most a single item which is emitted by this <code>Single</code>.</dd>
</dl>
</li>
</ul>
<a id="toCompletable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletable</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;toCompletable()</pre>
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors the terminal signal from this <code>Single</code>.</dd>
</dl>
</li>
</ul>
<a id="ignoreElement()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignoreElement</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;ignoreElement()</pre>
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors the terminal signal from this <code>Single</code>.</dd>
</dl>
</li>
</ul>
<a id="toCompletionStage()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletionStage</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.CompletionStage&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;toCompletionStage()</pre>
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>CompletionStage</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>CompletionStage</code> that mirrors the terminal signal from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="toFuture()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toFuture</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.Future&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;toFuture()</pre>
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>Future</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that mirrors the terminal signal from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeInternal(io.servicetalk.concurrent.SingleSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeInternal</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;subscribeInternal&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</pre>
<div class="block">A internal subscribe method similar to <a href="../SingleSource.html#subscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>SingleSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to subscribe for the result.</dd>
</dl>
</li>
</ul>
<a id="subscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&nbsp;subscribe&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;resultConsumer)</pre>
<div class="block">Subscribe to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, emits the result to the passed <code>Consumer</code> and log any
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultConsumer</code> - <code>Consumer</code> to accept the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> used to invoke <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> on the parameter of
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> for this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleSubscribe</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;handleSubscribe&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</pre>
<div class="block">Handles a subscriber to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - the subscriber.</dd>
</dl>
</li>
</ul>
<a id="succeeded(java.lang.Object)">
<!--   -->
</a><a id="succeeded(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>succeeded</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;succeeded&#8203;(@Nullable
                                      T&nbsp;value)</pre>
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes successfully with the provided <code>value</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromCallable(java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromCallable</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromCallable&#8203;(java.util.concurrent.Callable&lt;T&gt;&nbsp;callable)</pre>
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Callable.call()</code> on the passed
 <code>Callable</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error
 emitted by the <code>Callable</code> will terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> with the same error.
 <p>
 Blocking inside <code>Callable.call()</code> will in turn block the subscribe call to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. If
 this behavior is undesirable then the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> should be offloaded using
 <a href="#subscribeOn(io.servicetalk.concurrent.Executor)"><code>subscribeOn(io.servicetalk.concurrent.Executor)</code></a> which offloads the subscribe call.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callable</code> - <code>Callable</code> which supplies the result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromSupplier(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromSupplier</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromSupplier&#8203;(java.util.function.Supplier&lt;T&gt;&nbsp;supplier)</pre>
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Supplier.get()</code> on the passed
 <code>Supplier</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error
 emitted by the <code>Supplier</code> will terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> with the same error.
 <p>
 Blocking inside <code>Supplier.get()</code> will in turn block the subscribe call to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. If
 this behavior is undesirable then the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> should be offloaded using
 <a href="#subscribeOn(io.servicetalk.concurrent.Executor)"><code>subscribeOn(io.servicetalk.concurrent.Executor)</code></a> which offloads the subscribe call.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>supplier</code> - <code>Supplier</code> which supplies the result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="failed(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failed</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;failed&#8203;(java.lang.Throwable&nbsp;cause)</pre>
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes with the provided error <code>cause</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cause</code> - result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;never()</pre>
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that never terminates.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="defer(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defer</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;defer&#8203;(java.util.function.Supplier&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singleSupplier)</pre>
<div class="block">Defer creation of a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> till it is subscribed to.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singleSupplier</code> - <code>Supplier</code> to create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> every time the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is
 subscribed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> using <code>singleSupplier</code> every time
 it is subscribed and forwards all items and terminal events from the newly created <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to its
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromFuture(java.util.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromFuture&#8203;(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future)</pre>
<div class="block">Convert from a <code>Future</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> via <code>Future.get()</code>.
 <p>
 Note that because <code>Future</code> only presents blocking APIs to extract the result, so the process of getting the
 results will block. The caller of subscribe is responsible for offloading if necessary, and also offloading if
 <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> will be called and this operation may block.
 <p>
 To apply a timeout see <a href="#timeout(long,java.util.concurrent.TimeUnit)"><code>timeout(long, TimeUnit)</code></a> and related methods.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The data type the <code>Future</code> provides when complete.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>future</code> - The <code>Future</code> to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that derives results from <code>Future</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#timeout(long,java.util.concurrent.TimeUnit)"><code>timeout(long, TimeUnit)</code></a></dd>
</dl>
</li>
</ul>
<a id="collectUnordered(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnordered(java.lang.Iterable,int)"><code>collectUnordered(Iterable, int)</code></a> should be used. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(java.lang.Iterable)"><code>collectUnorderedDelayError(Iterable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnordered(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnordered(int,io.servicetalk.concurrent.api.Single...)"><code>collectUnordered(int, Single[])</code></a> should be used. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(io.servicetalk.concurrent.api.Single...)"><code>collectUnorderedDelayError(Single[])</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnordered(java.lang.Iterable,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                                                                   int&nbsp;maxConcurrency)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(java.lang.Iterable,int)"><code>collectUnorderedDelayError(Iterable, int)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnordered(int,io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(int&nbsp;maxConcurrency,
                                                                   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(int,io.servicetalk.concurrent.api.Single...)"><code>collectUnorderedDelayError(int, Single[])</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnorderedDelayError(java.lang.Iterable,int)"><code>collectUnorderedDelayError(Iterable, int)</code></a>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(java.lang.Iterable)"><code>collectUnordered(Iterable)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
             // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnordered(int,io.servicetalk.concurrent.api.Single...)"><code>collectUnordered(int, Single[])</code></a>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(io.servicetalk.concurrent.api.Single...)"><code>collectUnordered(Single[])</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
              // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(java.lang.Iterable,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                                                                             int&nbsp;maxConcurrency)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(java.lang.Iterable,int)"><code>collectUnordered(Iterable, int)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
             // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(int,io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(int&nbsp;maxConcurrency,
                                                                             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(java.lang.Iterable,int)"><code>collectUnordered(Iterable, int)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
             // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="fromStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromStage</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromStage&#8203;(java.util.concurrent.CompletionStage&lt;? extends T&gt;&nbsp;stage)</pre>
<div class="block">Convert from a <code>CompletionStage</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 A best effort is made to propagate <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> to the <code>CompletionStage</code>. Cancellation for
 <code>CompletionStage</code> implementations will result in exceptional completion and invoke user
 callbacks. If there is any blocking code involved in the cancellation process (including invoking user callbacks)
 you should investigate if using an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> is appropriate.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The data type the <code>CompletionStage</code> provides when complete.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stage</code> - The <code>CompletionStage</code> to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that derives results from <code>CompletionStage</code>.</dd>
</dl>
</li>
</ul>
<a id="amb(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>amb</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;amb&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first. Therefore the result is said to be <strong>ambiguous</strong>
 relative to which source it originated from. After the first source terminates the non-terminated sources will be
 cancelled.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to subscribe to and race to propagate to the return value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first. Therefore the result is said to be <strong>ambiguous</strong>
 relative to which source it originated from.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="amb(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>amb</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;amb&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first. Therefore the result is said to be <strong>ambiguous</strong>
 relative to which source it originated from. After the first source terminates the non-terminated sources will be
 cancelled.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to subscribe to and race to propagate to the return value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first. Therefore the result is said to be <strong>ambiguous</strong>
 relative to which source it originated from.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="anyOf(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyOf</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;anyOf&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to subscribe to and race to propagate to the return value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="anyOf(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyOf</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;anyOf&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s to subscribe to and race to propagate to the return value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="zip(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre class="methodSignature">public static&nbsp;&lt;T1,&#8203;T2,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zip&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
                                                  <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
                                                  java.util.function.BiFunction&lt;? super T1,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted
 by <code>s1</code> and <code>s2</code>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T1&gt; f1 = ...; // s1
      CompletableFuture&lt;T2&gt; f2 = ...; // s2
      CompletableFuture.allOf(f1, f2).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), f2.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - The type for the first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T2</code> - The type for the second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s1</code> - The first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s2</code> - The second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>s1</code> and <code>s2</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zipDelayError(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T1,&#8203;T2,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zipDelayError&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
                                                            <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
                                                            java.util.function.BiFunction&lt;? super T1,&#8203;? super T2,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted
 by <code>s1</code> and <code>s2</code>. If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 will wait for termination till all the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated, and then
 terminate with the first error.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T1&gt; f1 = ...; // s1
      CompletableFuture&lt;T2&gt; f2 = ...; // s2
      CompletableFuture.allOf(f1, f2).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), f2.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - The type for the first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T2</code> - The type for the second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s1</code> - The first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s2</code> - The second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>BiFunction</code> to items emitted by
 <code>s1</code> and <code>s2</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zip(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function3)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre class="methodSignature">public static&nbsp;&lt;T1,&#8203;T2,&#8203;T3,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zip&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
                                                           <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
                                                           <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
                                                           <a href="Function3.html" title="interface in io.servicetalk.concurrent.api">Function3</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function3.html" title="interface in io.servicetalk.concurrent.api"><code>Function3</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, and <code>s3</code>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T1&gt; f1 = ...; // s1
      CompletableFuture&lt;T2&gt; f2 = ...; // s2
      CompletableFuture&lt;T3&gt; f3 = ...; // s3
      CompletableFuture.allOf(f1, f2, f3).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), f2.get(), f3.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - The type for the first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T2</code> - The type for the second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T3</code> - The type for the third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s1</code> - The first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s2</code> - The second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s3</code> - The third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function3.html" title="interface in io.servicetalk.concurrent.api"><code>Function3</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, and <code>s3</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zipDelayError(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function3)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T1,&#8203;T2,&#8203;T3,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zipDelayError&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
                                                                     <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
                                                                     <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
                                                                     <a href="Function3.html" title="interface in io.servicetalk.concurrent.api">Function3</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function3.html" title="interface in io.servicetalk.concurrent.api"><code>Function3</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, and <code>s3</code>. If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated,
 and then terminate with the first error.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T1&gt; f1 = ...; // s1
      CompletableFuture&lt;T2&gt; f2 = ...; // s2
      CompletableFuture&lt;T3&gt; f3 = ...; // s3
      CompletableFuture.allOf(f1, f2, f3).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), f2.get(), f3.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - The type for the first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T2</code> - The type for the second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T3</code> - The type for the third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s1</code> - The first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s2</code> - The second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s3</code> - The third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function3.html" title="interface in io.servicetalk.concurrent.api"><code>Function3</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, and <code>s3</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zip(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function4)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre class="methodSignature">public static&nbsp;&lt;T1,&#8203;T2,&#8203;T3,&#8203;T4,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zip&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
                                                                    <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
                                                                    <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
                                                                    <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T4&gt;&nbsp;s4,
                                                                    <a href="Function4.html" title="interface in io.servicetalk.concurrent.api">Function4</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? super T4,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function4.html" title="interface in io.servicetalk.concurrent.api"><code>Function4</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T1&gt; f1 = ...; // s1
      CompletableFuture&lt;T2&gt; f2 = ...; // s2
      CompletableFuture&lt;T3&gt; f3 = ...; // s3
      CompletableFuture&lt;T4&gt; f4 = ...; // s3
      CompletableFuture.allOf(f1, f2, f3, f4).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), f2.get(), f3.get(), f4.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - The type for the first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T2</code> - The type for the second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T3</code> - The type for the third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T4</code> - The type for the fourth <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s1</code> - The first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s2</code> - The second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s3</code> - The third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s4</code> - The fourth <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function4.html" title="interface in io.servicetalk.concurrent.api"><code>Function4</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zipDelayError(io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Single,io.servicetalk.concurrent.api.Function4)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T1,&#8203;T2,&#8203;T3,&#8203;T4,&#8203;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zipDelayError&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T1&gt;&nbsp;s1,
                                                                              <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T2&gt;&nbsp;s2,
                                                                              <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T3&gt;&nbsp;s3,
                                                                              <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T4&gt;&nbsp;s4,
                                                                              <a href="Function4.html" title="interface in io.servicetalk.concurrent.api">Function4</a>&lt;? super T1,&#8203;? super T2,&#8203;? super T3,&#8203;? super T4,&#8203;? extends R&gt;&nbsp;zipper)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function4.html" title="interface in io.servicetalk.concurrent.api"><code>Function4</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code>. If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>  will wait for termination till all the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and
 terminated, and then terminate with the first error.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      CompletableFuture&lt;T1&gt; f1 = ...; // s1
      CompletableFuture&lt;T2&gt; f2 = ...; // s2
      CompletableFuture&lt;T3&gt; f3 = ...; // s3
      CompletableFuture&lt;T4&gt; f4 = ...; // s3
      CompletableFuture.allOf(f1, f2, f3, f4).get(); // wait for all futures to complete
      return zipper.apply(f1.get(), f2.get(), f3.get(), f4.get());
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - The type for the first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T2</code> - The type for the second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T3</code> - The type for the third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>T4</code> - The type for the fourth <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>s1</code> - The first <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s2</code> - The second <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s3</code> - The third <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>s4</code> - The fourth <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to zip.</dd>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <a href="Function4.html" title="interface in io.servicetalk.concurrent.api"><code>Function4</code></a> to items emitted by
 <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zip(java.util.function.Function,io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre class="methodSignature">public static&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zip&#8203;(java.util.function.Function&lt;? super java.lang.Object[],&#8203;? extends R&gt;&nbsp;zipper,
                                <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;?&gt;...&nbsp;singles)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>Function</code> to items emitted by
 <code>singles</code>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      Function&lt;? super CompletableFuture&lt;?&gt;[], ? extends R&gt; zipper = ...;
      CompletableFuture&lt;?&gt;[] futures = ...; // Provided Futures (analogous to the Singles here)
      CompletableFuture.allOf(futures).get(); // wait for all futures to complete
      return zipper.apply(futures);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dd><code>singles</code> - The collection of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that when complete provides the results to "zip" (aka combine)
 together.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>Function</code> to items emitted by
 <code>singles</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
<a id="zipDelayError(java.util.function.Function,io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>zipDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;zipDelayError&#8203;(java.util.function.Function&lt;? super java.lang.Object[],&#8203;? extends R&gt;&nbsp;zipper,
                                          <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;?&gt;...&nbsp;singles)</pre>
<div class="block">Create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>Function</code> to items emitted by
 <code>singles</code>. If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for
 termination till all the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated, and then terminate with the
 first error.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      Function&lt;? super CompletableFuture&lt;?&gt;[], ? extends R&gt; zipper = ...;
      CompletableFuture&lt;?&gt;[] futures = ...; // Provided Futures (analogous to the Singles here)
      CompletableFuture.allOf(futures).get(); // wait for all futures to complete
      return zipper.apply(futures);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - The result type of the zipper.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>zipper</code> - Used to combine the completed results for each item from <code>singles</code>.</dd>
<dd><code>singles</code> - The collection of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that when complete provides the results to "zip" (aka combine)
 together.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the results of a specified zipper <code>Function</code> to items emitted by
 <code>singles</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX zip operator.</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
